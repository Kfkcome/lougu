# 刷算法题总结

## CSP 题目

### 202212-2 训练计划 减少重复计算+模拟

这题的70分容易拿，只要的贪心+模拟就可以拿到70分，重点是最后的30分，就是求最晚时间求法。

最短时间的求法只要看被依赖的项目的时间就可以，不用看依赖的项目了，就是求最早时间的相反，但是其中还是有一定的bug容易错的。

一开始以为只要存储被依赖的项目就可以，但是还是根本过不了，

后来才发现被依赖的数量不止一个，就是一个项目可以被多个项目依赖，但是一个项目就只能依赖一个项目。

一开始还以为等价的为只要看被依赖项目的时间谁最长就记录下来，发现根本不行，必须要看被依赖项目的开始时间谁最晚才行。

### 2023-09-3 梯度求解 使用STL 大模拟

妈的终于找到错误了记录一下我检查出来的错误吧

1. 加法和减法的时候合并同类项，删除的时候，如果是同类项则删除一个

> ```c++
> formula add(formula a, formula b) // 多项式相加
> {
>     for (int i = 0; i < a.items.size(); i++)
>     {
>         for (int j = 0; j < b.items.size(); j++)
>         {
>             if (a.items[i].mp == b.items[j].mp)
>             {
>                 a.items[i].coefficient += b.items[j].coefficient;
>                 b.items.erase(b.items.begin() + j);
>                 j--;
>             }
>         }
>     }
>     for (int i = 0; i < b.items.size(); i++)
>     {
>         a.items.push_back(b.items[i]);
>     }
>     return formula(a.items);
> }
> 
> ```
>
> **注意j--这一步**

2. 然后就是

原本是一点思路也没有，看了一篇csdn的博客的思路，然后自己又手写了一份代码，还是没有100分，但是还是受益匪浅，对STL容器的一些操作进行了熟练。

比如结构体的初始化，可以有构造函数

````c++
struct item // 多项式的项
{
    map<int, int> mp;
    ll coefficient;
    item(ll coefficient, map<int, int> mp) : coefficient(coefficient), mp(mp) {}
};
struct formula
{
    vector<item> items; // 多项式
    formula(vector<item> items) : items(items) {}
};
````

然后就是容器的初始化

比如vector的

```c++
                item it(1, mp);
                formula f(vector<item>{it});
```

map的遍历

```c++
        for (auto it : a.items[i].mp)
        {
            ll temp2 = 1;
            for (int k = 0; k < it.second; k++)
            {
                temp2 = (temp2 * num[it.first]) % mod;
            }
            temp = (temp * temp2) % mod;
        }
```

vector的遍历

```c++
    for (int i = 0; i < a.items.size(); i++)
    {
        if (a.items[i].mp.find(x) != a.items[i].mp.end() && a.items[i].mp[x] != 0)
        {
            item temp = a.items[i];
            temp.coefficient *= temp.mp[x];
            temp.mp[x]--;
            if (temp.mp[x] == 0)
            {
                temp.mp.erase(x);
            }
            res.push_back(temp);
        }
    }
```

stringstream的使用

```c++
    getchar()//把之前一行的换行符吃掉
	string f;
    getline(cin, f);   
	stringstream ss(f);
    string temp;
    while (ss >> temp)
    {
```

stack 栈的使用

```c++
op.push(c); \\入栈
temp=op.top();  \\读取出战数据
op.pop(); \\出栈
```

### 2023-09-4  阴阳龙 使用set和map降低搜索时间复杂度（本质是使用了二分来优化搜索）

#### 题目重述

题目别看这么长，其实几句话就可以把题目大概讲清楚，就是先给你p个位置（是人的位置除非阴阳龙让他们旋转了，他们本身是不会动的），然后给你q个位置（是q个阴阳龙的位置，这个位置也可以看作是不动的），然后找到离每个阴阳龙的位置最近的人的位置（也就是距离最小），然后根据所在阴阳龙的位置旋转坐标，然后最后给出q次后的人的位置。

注意阴阳龙只会影响8个方向上的人。

#### 思路

一开始我是没有优化思路的，就是直接暴力，使用$n^2$的复杂度去搜索，然后发现直接超时，第一个样例就过不了，我们可以发现复杂度最大的就是q里面的搜索离阴阳龙最近的人的位置比较耗时间复杂度是$n$，但是当时没有想到合适的数据结构来，要是想到用二分搜索，然后使用set这个容器基本上这题就出来了。

其次最巧妙的就是使用了map算是一种离散化方式吧，而不是使用数组，map的索引时间复杂度是$log n$而set的二分搜索的复杂度也是$logn$ 最终的复杂度只有$nlogn$ 但是需要注意的点也有一些请看下面的介绍

> ```c++
> map<int ,int > 
> ```
>
> 本质上可以看做是一个一维整形数组，比数组的好的地方就是他的索引可以很大，而不占用那么大的连续空间，
>
> 这里我们使用了第一个int标识一条线第二个int表示存储位置
>
> ```c++
> map<int , int > mp[4]
> ```
>
> 这相当于是一个二维数组， // *存储位置和对应  mp[0]行 、mp[1]列 、mp[2]斜线 、mp[3]反斜线*

#### 遇到的问题、学习到的知识

set本质是一个红黑树，他自动将元素排序，如果我们看到二分搜索需要每次重新排序的，那么我们可以用set，我们只管往里插，他会自动排好序，并且复杂度是$logn$ ，然后这题就很适合，旋转的点后需要删除后重新插入然后排序，这里set就发挥作用了，复杂度降低很多。

1. 使用方法

``` c++
struct point//定义结构体
{
    int x, y;
    int id;
    point(int x, int y, int id) : x(x), y(y), id(id) {}
    point() {}

} peo[100001];
// 结构体符号重载，以遍set能够排序，注意必须要重载小于号，重载大于号没用
const bool operator<(struct point a, struct point b)
{
    if (a.x == b.x)
        return a.y < b.y;
    return a.x < b.x;
}

map<int, int> mp[4]; // 存储位置和对应  //0行  1列 2斜线 3反斜线
vector<set<point>> points;

```

2. 然后我按照上述思路写了以后发现仍然时间超时

原因竟然是我清楚set中的元素是使用的遍历清除

就是

```
set<point>::iterator it=points[pos].begin();
for(;it!=points[pos].end();it++)
{
	if(it->id==id)
	{
		points[pos].erase(it);
	}
}
```

这样的复杂度很高

应该使用自带的erase直接删除

````c++
    points[pos].erase(people);
````

这样复杂度只用$log n$

3. 遇到的坑爹问题

```c++
    for (int i = 0; i < len; i++)
    {
        if (resDis[i] == toPeo)
        {
            delete_mp(peo[miniDis[i].id]);
            changePoint(toPeo, miniDis[i], u, v, t);
        }
    }
    for (int i = 0; i < len; i++)
    {
        if (resDis[i] == toPeo)
        {
            insert_mp(peo[miniDis[i].id]);
        }
    }
```

注意这个delete_mp和insert_mp不能在一个循环中，因为set是会自动去重的，如果前面有的点插入到和后面的点相同的位置就被delete了，所以要全delete完才能插入

3. 遇到的小问题（太蠢了）

> ![42ade28fbe32fffc33b056f6d07a0bc9](D:\c++\luogu\总结.assets\42ade28fbe32fffc33b056f6d07a0bc9.png)
>
> 
>
> 这里u-1 v-1才对
>
> ![e9f8d06c6acb00b607017ac6b8c1d18d](D:\c++\luogu\总结.assets\e9f8d06c6acb00b607017ac6b8c1d18d.png)



#### 完整代码



### 2023-05-2  矩阵运算 用类似滚动数组降低空间复杂度

原本以为这题要用空间换时间的，结果是通过类似滚动数组的形式，降低空间复杂度

这题并不难，算是一个模拟吧

#### 前置知识

你要知道矩阵相乘事如何进行的

res{i,j}=a的第i行对应元素乘上b的第j列对应元素，累加求和得到的

依次算出整个res 

然后还有矩阵转置 就是行列互换，n*d 变成 d\*n

#### 思路

就是模拟矩阵相乘，转置，没啥可说的

转置我们可以不具体实现出来，就是知道对应位置就好，乘的时候用仔细想想这个元素对应转之前的元素在哪个位置然后直接取出即可。

**要注意的地方就是我们不能吧中间结果long long 才可以不损失精度**

**但是不能用10001x10001的long long 型数组存下来，不然会导致空间复杂度超过题目要求。**

同时我们发现矩阵乘法一行乘以一列的计算是行和行之间相互独立的，计算完一行可以扔掉一行，所以这样我们就可以把空间复杂度降下来。

#### 完整代码

### 2023–05-3 解压缩 大模拟（没有特殊算法）

这题实际并不难，主要是要注意一些细节，比较考验你的编程习惯和逻辑是否清晰

思路就是按题目的来模拟

题目其实并不难理解，就是先算引导区、再算数据区的数据

#### 遇到的问题

1. 第一个遇到的问题就是输出没有搞对

> 每行8个字节16个字符换一次行
>
> ```c++
>     for (int i = 0; i < allData.size(); i++)
>     {
>         if (i != 0 && i % 16 == 0)
>         {
>             cout << endl;
>         }
>         cout << allData[i];
>     }
> ```
>
> 然后从0分变成了40分
>
> ![image-20240226152527916](D:\c++\luogu\总结.assets\image-20240226152527916.png)

2. 没有想清楚pos的含义和字节的关系

> 就是这里应该对16取余但是对8取的余，并且重写了这块也就是对位运算转化为了十进制运算，逻辑更加清晰了，并且补充了对回溯引用的代码，然后就变成了60分，
>
> ```c++
>             else if (t % 4 == 2)
>             {
>                 l = t / 4 + 1;
>                 // 往后读取两个字节作为o
>                 o = hexToDec(string(temp[pos / 16].begin() + pos % 16, temp[pos / 16].begin() + pos % 16 + 2));
>                 pos += 2;
>                 o += hexToDec(string(temp[pos / 16].begin() + pos % 16, temp[pos / 16].begin() + pos % 16 + 2)) * 256;
>                 pos += 2;
>             }
> ```
>
> ![image-20240226152834746](D:\c++\luogu\总结.assets\image-20240226152834746.png)

3. 最坑的一个点就是对引导区长度计算的错误

> 本来是使用按位计算的
>
> 没有理清楚，并且不知道位运算的优先级是最低的（除去三元运算）详情请看[c++运算优先级](http://t.csdnimg.cn/mFuvn)
>
> 用的是
>
> ```c++
> if（num & 128 !=1)
> ```
>
> 这样不对这样num&128！=128才对
>
> 因为
>
> 1000 0000&1000 0000 = 1000 0000 
>
> 只有第一位是1时4才是1000 0000 也就是128
>
> 然后使用了十进制这样更清晰一点
>
> ```c++
> if(num<128)
> ```
>
> 然后就直接100分了
>
> ![image-20240226154024603](D:\c++\luogu\总结.assets\image-20240226154024603.png)

#### 完整代码

### 2023-03-3 LDAP 大模拟使用map构建索引优化搜索（本质是用空间换时间）

#### 思路

本题的思路就是使用一些数据结构把题目给的信息存储下来，然后根据匹配表达式的内容检索存储的信息。

一开始的难点是如何转换题目给的用户信息，就是根据语法来解析匹配语句（本质是解析字符串）

> 比如如何解析BASE_EXPR（这个解析好了，那么EXPR也就是加个递归的事）
>
> 首先固定的第一个符号肯定是操作符，然后重点就是匹配两个括号
>
> 想要匹配两个括号，我们可以重点匹配中间的那个）的位置，因为匹配到了这个的位置，全部的位置也就知道了
>
> 写好这些之后应该可以得到40分，然后剩下的是超时

然后的难点就是优化时间复杂度，重点就是使用特定的数据结构来索引

#### 学到的东西（遇到的问题）

1. 0到40分

> 这40分实际就是对应第一个难点，也还有一些细节问题比如要的对输出的dn按从大到小排序，
>
> 我其实就卡在了寻找括号的位置的算法上
>
> ```c++
>  int position[4]; // 记录四个括号符号的位置
>     position[0] = 1;
>     int pos = 0;
>     // 匹配括号的位置
>     for (int i = 2; i < temp.size(); i++)
>     {
>         if (temp[i] == '(')
>         {
>             pos++;
>         }
>         if (temp[i] == ')')
>         {
>             if (pos != 0)
>             {
>                 pos--;
>             }
>             else
>             {
>                 position[1] = i;
>                 position[2] = i + 1;
>                 position[3] = temp.size() - 1;
>                 break;
>             }
>         }
>     }
> ```
>
> 这样才是正确的
>
> **然后就是排序问题，以后不管题目只要给了输出要求就要去实现，不能以为输入是按从小到大的排序就输出不用再进行排序了。**

2. set是自动排序的并且自动去重（从小到大）

> 一开始没有想到用直接用set存ans，是先用vector存了然后再转成了set，然后就会导致时间复杂度变高，不如直接使用set进行存储，然后就变成了60分
>
> ![image-20240229113100573](./%E6%80%BB%E7%BB%93.assets/image-20240229113100573.png)

3. 优化搜索

> 优化搜索的重点是这个函数
>
> ```c++
> void solveBase(vector<int> &t, string temp)
> {
>     // 寻找操作operator,并且分解出属性和值
>     int id, val, op; // 如果op是1 则符号是：如果op是0 则符号是~
>     for (int i = 0; i < temp.size(); i++)
>     {
>         if (temp[i] == ':' || temp[i] == '~')
>         {
>             if (temp[i] == ':')
>                 op = 1;
>             else
>                 op = 0;
>             id = stoi(string(temp.begin(), temp.begin() + i));
>             val = stoi(string(temp.begin() + i + 1, temp.end()));
>             break;
>         }
>     }
>     for (int i = 0; i < n; i++)
>     {
>         if (op && user[i].value.find(id) != user[i].value.end() && user[i].value[id] == val)
>         {
>             t.push_back(i);
>         }
>         else if (!op && user[i].value.find(id) != user[i].value.end() && user[i].value[id] != val)
>         {
>             t.push_back(i);
>         }
>     }
> }
> ```
>
> 
>
> 1. 里面或者for循环太大了能不能优化下呢？
>
> 答案是可以的，我们其实可以事先把有这个属性的user给存到一个set里面然后搜索的时候就不用全部搜索了，
>
> 只用搜索有这个属性的user就好了。
>
> 优化后是这样的
>
> ```c++
> void solveBase(set<int> &t, string temp)
> {
>     // 寻找操作operator,并且分解出属性和值
>     int id, val, op; // 如果op是1 则符号是：如果op是0 则符号是~
>     for (int i = 0; i < temp.size(); i++)
>     {
>         if (temp[i] == ':' || temp[i] == '~')
>         {
>             if (temp[i] == ':')
>                 op = 1;
>             else
>                 op = 0;
>             id = stoi(string(temp.begin(), temp.begin() + i));
>             val = stoi(string(temp.begin() + i + 1, temp.end()));
>             break;
>         }
>     }
>     for (auto i : args[id])
>     {
>         if (op && user[i].value[id] == val)
>         {
>             t.insert(user[i].dn);
>         }
>         if (!op && user[i].value[id] != val)
>         {
>             t.insert(user[i].dn);
>         }
>     }
> }
> ```
>
> 然后就会有70分
>
> ![image-20240229114146666](./%E6%80%BB%E7%BB%93.assets/image-20240229114146666.png)
>
> 2. 我们继续按着这个思路往下想，我们是不是可以按属性、属性的值存储dn呢？
>
> 那么在搜索某个属性等于某个值的时**是否可以直接取出来，**而不用再搜索呢？
>
> 答案是可以的。
>
> **但是对于求某个属性不等于某个值的怎么办呢？**要继续搜索嘛？这样时间复杂度就会没有变化，所以我们要是用的逆向思维，我们其实可以**将有这个属性的全部user都添加进来，然后再删除和那个属性值相等的user的dn**
>
> 3. **为什么这样可以降低复杂度呢？**
>
> **实际是因为如果用for循环来insert的话复杂度是O(n)而直接用insert插入区间的话是O(logn)这样时间复杂度降低很多**
>
> 改完之后的代码就是这样
>
> ```c++
> void solveBase(unordered_set<int> &t, string temp)
> {
>     // 寻找操作operator,并且分解出属性和值
>     int id, val, op; // 如果op是1 则符号是：如果op是0 则符号是~
>     for (int i = 0; i < temp.size(); i++)
>     {
>         if (temp[i] == ':' || temp[i] == '~')
>         {
>             if (temp[i] == ':')
>                 op = 1;
>             else
>                 op = 0;
>             id = stoi(string(temp.begin(), temp.begin() + i));
>             val = stoi(string(temp.begin() + i + 1, temp.end()));
>             break;
>         }
>     }
>     if (op)
>     {
>         t.insert(artt[id][val].begin(), artt[id][val].end());
>     }
>     else
>     {
>         t.insert(args[id].begin(), args[id].end()); // 先把所有有这个属性的dn加入
>         for (auto item : artt[id][val])
>             t.erase(item); // 然后清楚和这个值相等的dn
>     }
> }
> 
> ```
>
> 我们发现其中中间很多数据结构是不用排序的，排序反而会增加时间复杂度，我们其实可以使用unordered的容器

5. 使用unordered的数据结构

unordered的数据结构插入和删除和取出都是O(1)而有排序的数据结构插入和删除是O(logn) 的所以时间复杂度要高一些，我们的排序也可以放在最后进行。

**注意unordered_set 的排序需要转换成vector后再用sort的排序。**

6. 使用o2优化

> ```c++
>     ios::sync_with_stdio(false);
>     cin.tie(0);
>     cout.tie(0);
> ```

这样我们就勉勉强强获得了100分

![image-20240229115429384](./%E6%80%BB%E7%BB%93.assets/image-20240229115429384.png)

这种map嵌套map的组合很值得学习，map的键一般不用结构体所以可以用map嵌套map来使用。

#### 完整代码

### 2022-12-2 训练计划 递推但是有坑（重点不是优化是坑）（完美的犯了两次）

这题其实并不难，但是有一个坑你如果只用题目的数据的话一定想不到，得自己造数据才能发现。就是我们的思路总是片面的想不到那么全面，可是也没有好的办法来一下提升自己思路的全面的问题，只能我们就是得自己根据题目造一些数据，去发现隐藏在题目中的限制。

我们的思路总是根据题目给出的数据想出来的，那么我们的思路就有可能只符合这个数据，想要拓宽拿满分我们就要造一些数据，**就是不管怎么样，我们都要做点什么，不能卡住了就不动了，**那样肯定不能改进。

#### 思路

我们其实很容易看到题目就刻意的想要让你用递归（也包含一点贪心的思想），这点其实大多数人都能想出来。

求最早开始时间，我们可以发现每个科目的最早开始时间只跟他的前置依赖科目有关（算是马尔可夫性吧hhh），然后我们求这个科目的最早开始时间就是通过前置依赖科目的最早开始时间计算的，而且自己依赖的科目又在自己的前面，保证了更新自己前依赖科目已经更新了。

求最晚开始时间，我们可以想到，就是每个科目的最晚开始时间是跟自己的后置依赖科目有关，然后就像求最早开始时间一样求最晚开始时间，只不过是反过来遍历。（注意这里有坑，后面会提到）

#### 遇到的问题（学到的东西）

发现这次刷出现的问题和上次出现的简直不要一摸一样，看来我还是没有在犯错中长进，人真的很难改进错误，就像狗改不了吃shit呢hhhh

但是还是希望这次记住了以后不要再犯了。

1. 依赖数量问题

一开始以为只要存储被依赖的项目就可以，但是还是根本过不了，

后来才发现被依赖的数量不止一个，就是一个项目可以被多个项目依赖，但是一个项目就只能依赖一个项目。我们不知不觉的就假设了一个课程只被一个课程依赖，但是实际并不是这样的。

2. 求最晚开始时间

一开始还以为等价的为只要看被依赖项目的时间谁最长就记录下来，发现根本不行，必须要看被依赖项目的开始时间谁最早才行。因为被依赖的项目的时间最长，不一定最早，得看最早开始时间。

#### 完整代码

### 2022-12-3 JPEG 解码 大模拟 不需要任何优化手段 最简单的第三题

这题堪称是最简单的第三题，没有用到任何的优化手段，没有用到任何的特殊的数据结构，只需要按着题目来就好了。

#### 思路

这题只要是看懂题目了就基本有思路，稍微有一个难点就是模拟那个z字形的填充。

模拟z字形的填充有两种方式，第一种就是找到z字形填充的数学映射，就是第i个数该插在 第u行第v列的映射关系，这种是比较困难的，需要有较强的数学推导和归纳总结能力，我一开始想这样处理但是发现自己找不到规律。

第二种就是直接模拟z字形填充的过程，判断好什么时候右移，什么时候下移，等等的，然后在循环里移动就好了。

> 具体实现就是这个函数，这种思路非常的通俗易懂
>
> ![fill.png](./%E6%80%BB%E7%BB%93.assets/RequireFile.png)
>
> 1. 如果是上半个矩阵
>    1. 如果这一行（斜着的行）往右上角移动那么这行结束时要右移
>    2. 如果这一行（斜着的行）往左下角移动那么这行结束时就要下移
>
> 1. 如果是下半个矩阵
>    1. 大家可以自己想一想
>
> ```c++
> 
> void insertMatrix()
> {
>     // 首先插入上半个矩阵
>     int x = 0, y = 0, moveflag = 1; // moveflag如果是右移则是1 如果是下移则是0
>     for (int i = 1; i <= 8; i++)//上半个矩阵一共有8行（斜着的行）
>     {
>         for (int j = 1; j <= i; j++)//每一行的数量是1 2 3 4…………8
>         {
>             m[x][y] = data1[top++];
> 
>             if (top == n) // 已经把所有数据都插入了
>             {
>                 return;
>             }
>             if (j != i && moveflag == 1)
>             {
>                 x--;
>                 y++;
>             }
>             else if (j != i && moveflag == 0)
>             {
>                 x++;
>                 y--;
>             }
>         }
>         if (moveflag == 1) // 如果是右移
>         {
>             y++;
>         }
>         else if (moveflag == 0)
>         {
>             x++;
>         }
>         moveflag = !moveflag;
>     }
> 
>     moveflag = 0;
>     x = 7, y = 1;
>     // 然后插入下半个矩阵
>     for (int i = 7; i >= 1; i--)//下半个矩阵一共有7行（斜着的行）
>     {
>         for (int j = 1; j <= i; j++)//每一行的数量是7 6 5 …… 1
>         {
>             m[x][y] = data1[top++];
>             if (top == n) // 已经把所有数据都插入了
>             {
>                 return;
>             }
>             if (j != i && moveflag == 1)
>             {
>                 x++;
>                 y--;
>             }
>             else if (j != i && moveflag == 0)
>             {
>                 x--;
>                 y++;
>             }
>         }
>         if (moveflag == 1) // 如果是右移
>         {
>             y++;
>         }
>         else if (moveflag == 0) // 如果是下移
>         {
>             x++;
>         }
>         moveflag = !moveflag;
>     }
> }
> ```
>
> 但是其中还是有一点坑的地方。

#### 遇到的问题

1. 下半个矩阵的填充规则和上半个矩阵并不相同，一开始以为相同就搞错了，和上半个矩阵的规则整相反，如果是往右上角移动那么最后要向下移动。

> 没有修改之前
>
> ![image-20240304172616620](./%E6%80%BB%E7%BB%93.assets/image-20240304172616620.png)
>
> 修改之后
>
> ![image-20240304172628258](./%E6%80%BB%E7%BB%93.assets/image-20240304172628258.png)

2. 在过了第一个测试点之后就写了量化的代码，但是发现还是20分，然后才发现是我的量化矩阵和数据的矩阵的ij对不上，量化矩阵式从1开始的而数据矩阵是从0开始的，修改之后就好了。

> 修改之前
>
> ![image-20240304172720372](./%E6%80%BB%E7%BB%93.assets/image-20240304172720372.png)
>
> 修改之后
>
> ![image-20240304172745380](./%E6%80%BB%E7%BB%93.assets/image-20240304172745380.png)

3. 在完成了第二个测试点后，写了dct变化的代码，然后输出中间数据发现，和题目给的经过dct变化后的结果不一样，后来发现是公式写错了

> 这里的 DctConvert里的数据写错了
>
> ```c++
> double a1 = i == 0 ? sqrt(0.5) : 1, a2 = j == 0 ? sqrt(0.5) : 1;
> ```
>
> 我写成了 
>
> ```c++
> double a1 = x == 0 ? sqrt(0.5) : 1, a2 = y == 0 ? sqrt(0.5) : 1;
> 
> ```
>
> 正确的函数
>
> ```c++
> double DctConvert(int x, int y)
> {
>     double sum = 0;
>     for (int i = 0; i < 8; i++)
>     {
>         for (int j = 0; j < 8; j++)
>         {
>             double a1 = i == 0 ? sqrt(0.5) : 1, a2 = j == 0 ? sqrt(0.5) : 1;
>             sum += a1 * a2 * m[i][j] * cos(pi8 * (x + 0.5) * i) * cos(pi8 * (y + 0.5) * j);
>         }
>     }
>     return sum / 4;
> }
> ```
>
> 也就是题目中的$\alpha(u) \ \ \ \alpha(v)$给搞错了

4. 最后补上了取整的代码就是还是40分

> 这里学会了一个四舍五入为整数的函数
>
> round()
>
> 其实我们也可以手写round()函数
>
> 就是
>
> ```c++
> int round(double x)
> {
>     return (int)x+0.5
> }
> ```
>
> **如果我们要求其他位的四舍五入，可以先乘个10，然后四舍五入为整数，然后再除以个10**

**这里遇到的问题就是**：忽略了题目的一个规则

> 如果得到的整数大于 255，则取 255；如果得到的整数小于 0，则取 0。

补上这个条件就100分了

![image-20240304173808476](./%E6%80%BB%E7%BB%93.assets/image-20240304173808476.png)

#### 感悟

这题确实很简单，主要是题目限制了一个特定的数据范围，然后直接暴力就可以求解。

遇到问题后应该再仔细读一读题目，将题目的条件都列下来，然后并且把自己的推论也都列出来，看看哪些推论是自己乱想的，并且检查还有没有漏掉的。

如果一直满分不了，那么一定是还有问题，有可能是实现的细节问题，也有可能是思路的问题（没有想全面，只是按着给的样例的数据了），还有可能是读题问题（有地方没有读到被忽略了）。

#### 完整代码

### 2022-09-2 何以包邮？ 拐个弯的动态规划（01背包问题）/深搜+剪枝

这题由于其数据的量并不大我们可以有两种思路来解决这个问题。

#### 动态规划思路

这道题其实得先想到的是动态规划，然后拼命的往上靠，或许才能想出来拐个弯。

01背包问题都是在不超过一定容量下，求最大价值是多少，然后我们就可以将重量当作价值，就可以求出在一定容量下，求最大的占用的容量是多少。但是这个题目时求超出一定容量下最小的容量占用是多少，此时我们就可以反着想。

题目让我们求出要选的书，我们其实也可以选出不选的书，然后剩下就是要选的书，总共的价钱减去不选的书的钱就是剩下的钱。所以这就转换成了01背包问题 容量为sum–x价值是a[i]（重量）的01背包问题。

#### 遇到的问题（补一些01背包的知识）

1. 首先01背包问题大家可以在网上搜到很多资源，解释的也很好，这里就简要的写一下

> 01背包的状态转移方程
>
> $$f_{i,j}=max(f_{i,j},f_{i,j-w_i}+v_i)$$

然后针对这个题目的状态转移方程就是

$$f_{i,j}=max(f_{i,j},f_{i,j-w_i}+w_i)$$

$f_{i,j}$代表的是从前i本书中选择，在不超过容量为j的情况下，最大的容量（价值）

2. 实现过程中遇到了一些问题

>   第一个问题就是发现这个代码是错误的
>
> ```c++
> for (int i = 1; i <= n; i++)
> {
>     for (int j = 1; j <= sum-x; j++)
>     {
>             dp[j] = max(dp[j], dp[j - a[i]] + a[i]);
>     }
> }
> ```
>
> 大家可以想想为什么
>
> **后来发现是01背包的状态转移方程是有条件的，也就是说这个状态转移方程也是要条件的**
>
> ```c++
>     for (int i = 1; i <= n; i++)
>     {
>       for (int j = 1; j <= sum-x; j++)
>         {
>             if (j >= a[i])
>                 dp[j] = max(dp[j], dp[j - a[i]] + a[i]);
>         }
>     }
> ```
>
> **但是还是有问题，发现求得的答案总是比正确答案小，**
>
> 然后就突然想到了，使用滚动数组的问题，就是很容易出现后效性的问题，就是本阶段不仅会使用上一个阶段更新，还会使用本阶段更新的更新，这样就会变成完全背包问题
>
> 应该改成这样
>
> ```c++
>     for (int i = 1; i <= n; i++)
>     {
>         for (int j = sum - x; j >= 1; j--)
>         {
>             if (j >= a[i])
>                 dp[j] = max(dp[j], dp[j - a[i]] + a[i]);
>         }
>     }
> ```
>
> **这一样$f_{i,j}$只会被$f_{i-1}+w_i$更新，而不会被$f_{i}+w_i$更新**

至此动态规划就可以拿100分了。

![image-20240304214349386](./%E6%80%BB%E7%BB%93.assets/image-20240304214349386.png)

#### 深搜+剪枝思路

这题的数据其实有问题，后边30%的数据都是x比较接近所有书价钱的总和，也就是说如果我们反着深搜，就不会超时。同时我们也得剪枝来降低复杂度。

我们可以先求所有书的价钱的总和sum，然后让sum减去a[i]，求不买的书的

然后当sum<x之后就把这支剪掉

求得的sum就是最小的大于 x 的值了。

#### 完整代码



### 2022–12-4 聚集方差 暴力混分 65分思路 没有算法纯模拟

这题原本是需要优化的算法，但是鉴于我弱鸡的实力，考试的时候肯定是不会A出来的第四题的100分的，最多混一混（要是能混到也算是很不错了）。所以这题我就尝试使用暴力来解题，没想到还是拿到了超过了一半的分数。

但是从这道题我也明白了就算是混分也是需要训练的。

#### 题目重述

这题别看那么多公式什么的，实际上就是几句话就能解释清楚。

首先背景是一个公司的，可以用一棵树来表示，上级就是父节点，下属就是子节点，然后对于每个节点我们可以获取一个可重复集合，就是包括自己所有的子节点（包括子节点的子节点，儿子的儿子……）就是整个子树的节点，和自己的集合。

之后我们明白这个集合，然后我们可以针对每一个集合计算一个ans 然后输出。这个ans计算方法就是，遍历这个集合中的所有元素找到离他最近的元素（不能是他自己）然后求出距离后平方，最后ans再加上这个值。

#### 思路

主要就是分两部分，第一部分是求得每个节点的集合，第二部分就是求个每个集合的ans。

第一部分，我们先可以把每个节点的第一层子节点保存下来，然后再递归把每个节点的子树的所有的节点加进去

第二部分，我们先对每个集合进行排个序，然后遍历里面的每个元素，找前后两个点看谁最近，然后加到ans中，最后输出（有个特殊情况，就是只有一个节点的集合求出是0）

#### 遇到的问题（学到的知识）

1. 思路问题

本来想着直接用一个递归函数求得，就是边求集合边求每个元素的离得最近的距离，但是发现不太可行，因为集合不仅是每个节点的子节点，而且是整个子树（包含儿子的儿子）

这是幡然醒悟，然后开始写。

2. 实现问题：找子节点无限递归无限循环

原来是因为我把每个节点的字节点存到了集合中，也把那个节点本身也存到的集合中，这样就会无限递归不能停止，而且会导致重复添加的问题。

> 修改办法就是：区别对待添加个if
>
> ```c++
> void getChild(int i, int j)           // 父节点是i 子节点是j  要把j的所有子节点都填入到i的child数组中
> {
>     if (child1[j].size() == 1)
>     {
>         child[i].push_back(child1[j][0]);
>         return;
>     }
>     for (auto item : child1[j])
>     {
>         if (item.id == j) // 因为此数组中包括本节点，防止无限递归所以使用了特殊处理此节点
>         {
>             child[i].push_back(item);
>         }
>         else
>             getChild(i, item.id);
>     }
> }
> ```

3. 还是发现总是有重复添加

原来在初始的第一层循环中，也是出现了上面的问题，也就是我遍历的两边子树，添加了两遍子树

> 修改前
>
> ```c++
>     for (int i = 1; i <= n; i++)
>     {
>         for (auto item : child1[i])
>         {
>             getChild(i, item.id);
>         }
>     }
> ```
>
> 修改后
>
> ```c++
>     for (int i = 1; i <= n; i++)
>     {
>         for (auto item : child1[i])
>         {
>             if (item.id == i)
>             {
>                 child[i].push_back(item);
>             }
>             else
>                 getChild(i, item.id);
>         }
>     }
> ```

至此求集合的过程就结束了。然后是求ans的过程

4. 求ans的过程其实比较简单，但是有一个非常坑的地方，以前都没有注意到。

首先可以发现是范围问题（虽然这个我也找了好久好久…………）然后将anx这个变量改为了long long 类型，但是发现还是0分

![image-20240305155809383](./%E6%80%BB%E7%BB%93.assets/image-20240305155809383.png)

然后听到同学的建议，**将所有int改为了long long** 就变成40分

![image-20240305155905496](./%E6%80%BB%E7%BB%93.assets/image-20240305155905496.png)

**为什么会这样呢？**

> ```c++
>     for (int i = 1; i <= n; i++)
>     {
>         long long anx = 0; // 求和
>         for (int j = 0; j < child[i].size(); j++)
>         {
>             long long mini = 1e9 + 1;
>             if (j != 0)
>             {
>                 mini = min(abs(child[i][j].a - child[i][j - 1].a), mini);
>             }
>             if ((j + 1) != child[i].size())
>             {
>                 mini = min(abs(child[i][j].a - child[i][j + 1].a), mini);
>             }
>             if (mini != 1e9 + 1) // 有可能没有其他子节点了，所以就是加0 而不是（1e9)的平方
>                 anx += mini * mini;
>         }
>         cout << anx << endl;
>     }
> ```
>
> 首先是mini这个变量要设置为long long 为什么呢？
>
> **因为有mini * mini 这个$10^9 \times 10^9$ 的话会超出int 的范围，就算最后赋给了long long 的anx，但是那是在赋值阶段才升级为longlong的，也就是相乘的时候还是int，结果也会是int，这就会导致溢出**
>
> 然后我们只修改了mini为long long那么会**报错** ，因为min()这个函数没办法比较 long long 和 int 所以我们得将所有的改为long long 
>
> 至此就达到了65分
>
> ![image-20240305160459849](./%E6%80%BB%E7%BB%93.assets/image-20240305160459849.png)

其实还可以基于此进行优化，然后拿更高分数，有舍才有得，就先到这里了。

#### 完整代码

### 2022–09-3 防疫大数据 STL大模拟 使用map优化索引

这题中规中矩，不算太难也不算太简单，难点就是能否理清逻辑，**注意细节** （这题好坑找bug找了好久啊也怪自己太傻），但是这些错，自己不写是不知道的，还得自己找出来，加深自己的印象。

#### 基本思路

做csp的大模拟题的基本思路就是，将给的数据用一定的数据结构存起来，这个数据结构要方便后边搜索，然后题目的问题一般本质就是搜索。所以要仔细读题，**如果给出了形式化描述（数学表达式）尽量用题目给的表达式来写代码，这样错的概率更低**。

针对于本题，题目的数据分为两类，一类是城市数据，另一类游客的到访数据，然后题目就差不多是求他们两个的交集（用题目给定的规则来交）。

城市的数据是 给出有风险的城市的集合，**风险的开始日期是给出数据的日期**

游客的到访数据 是给出到访的时间 到访的地点 游客id  

**注意游客这里就有两个日期：收到到访数据的日期， 和访问的日期**

我们分别建立索引，城市用城市id建立索引、游客用收到数据的日期建立索引，然后搜索的时候，就会加快速度找到。

然后根据题目的要求来匹配

> 形式化地，在 d 日生成的风险名单中，用户 u 被列入风险名单，当且仅当：
>
> 存在一个日期 $d_0 \in (d-7,d]$，存在一条 $d_0$ 日收到的漫游数据 $<d_1,u,r>$，使得
>
> - $d_1 \in (d-7,d]$，并且
> - 对于任意的 $D \in [d_1,d]$，地区 r 在 D 日处于风险状态。

所以就是要遍历d日的前6天的到访数据，然后判断该地是不是风险地区在那个区间上。

#### 遇到的问题（学到的东西）

这题随便一写什么都不用考虑，只要模拟出来了基本都是40分，然后我一开始就是40分，然后怎么也找不到bug，然后逐渐找到了几个bug但是还是40分，最终参考别人的代码还是找到了bug，考场上要是找不到只能认栽了。

1. 风险地区的风险区间合并问题

这个问题我一开始，没有注意到，就是要把风险区间有交集的进行合并，但是这个合并的逻辑有了一点点问题，下面会提到

2. 风险地区的风险区间合并问题的实现

实现的过程中是后一个插入前一个的，但是会导致最后一个没有插入

> 修改之前
>
> ```c++
>     // 合并一下区间
>     for (auto item : place_time)
>     {
>         struct places temp;
>         temp.length = -1; // 标记为还没初始化
>         for (auto p : item.second)
>         {
>             if (temp.length != -1 && p.day >= temp.day && p.day <= temp.day + temp.length)
>             {
>                 int end1 = p.day + p.length - 1;
>                 int end2 = temp.day + temp.length - 1;
>                 temp.length += end1 - end2;
>             }
>             else
>             {
>                 place_time2[item.first].push_back(temp);
>                 temp = p;
>             }
>         }
>     }
> ```
>
> 并且会报错，因为没有初始化的temp也会被插入
>
> 修改后的
>
> ```c++
>     // 合并一下区间
>     for (auto item : place_time)
>     {
>         struct places temp;
>         temp.length = -1; // 标记为还没初始化
>         for (auto p : item.second)
>         {
>             if (temp.length != -1 && p.day >= temp.day && p.day <= temp.day + temp.length)
>             {
>                 int end1 = p.day + p.length - 1;
>                 int end2 = temp.day + temp.length - 1;
>                 temp.length += end1 - end2;
>             }
>             else
>             {
>                 if (temp.length != -1)
>                     place_time2[item.first].push_back(temp);
>                 temp = p;
>             }
>         }
>         if (temp.length != -1)
>             place_time2[item.first].push_back(temp);
>     }
> ```

3. 判断是不是风险用户的问题

这点一开始是自己找的规律然后按着自己想到去判断的，没想到的少了一些条件，然后补上了，但是仍然是40分，之后百思不得其解

4. 区间合并的逻辑问题

原来这个区间合并，不只是有交集的区间合并，就算是没有交集但是中间没有间隔的区间也要合并的，这点我是看了别人的代码才想到的，考试要是碰见这个直接就g了

> 修改之前
>
> ```c++
>     // 合并一下区间
>     for (auto item : place_time)
>     {
>         struct places temp;
>         temp.length = -1; // 标记为还没初始化
>         for (auto p : item.second)
>         {
>             if (temp.length != -1 && p.day >= temp.day && p.day <= temp.day + temp.length-1)
>             {
>                 int end1 = p.day + p.length - 1;
>                 int end2 = temp.day + temp.length - 1;
>                 temp.length += end1 - end2;
>             }
>             else
>             {
>                 if (temp.length != -1)
>                     place_time2[item.first].push_back(temp);
>                 temp = p;
>             }
>         }
>         if (temp.length != -1)
>             place_time2[item.first].push_back(temp);
>     }
> ```
>
> 修改之后
>
> ```c++
>     // 合并一下区间
>     for (auto item : place_time)
>     {
>         struct places temp;
>         temp.length = -1; // 标记为还没初始化
>         for (auto p : item.second)
>         {
>             if (temp.length != -1 && p.day >= temp.day && p.day <= temp.day + temp.length)
>             {
>                 int end1 = p.day + p.length - 1;
>                 int end2 = temp.day + temp.length - 1;
>                 temp.length += end1 - end2;
>             }
>             else
>             {
>                 if (temp.length != -1)
>                     place_time2[item.first].push_back(temp);
>                 temp = p;
>             }
>         }
>         if (temp.length != -1)
>             place_time2[item.first].push_back(temp);
>     }
> ```
>
> 就是这个
>
> ```c++
>             if (temp.length != -1 && p.day >= temp.day && p.day <= temp.day + temp.length)
> ```
>
> 改变了

之后就可以拿到了100分，

![image-20240307163224207](./%E6%80%BB%E7%BB%93.assets/image-20240307163224207.png)

5. 还学到了使用freopen()

如果你的csp考场上 无法往终端里复制数据，可以直接使用

```c++
freopen("1.txt", "r", stdin);
```

注意1.txt是相对路径，可以替换成你的输入的路径，然后其他什么都不用改变，就可以了。

**（提交的时候要注释掉这个）**

#### 感悟

这题竟然是没有一次做出来，而且还是看了别人的思路才找出来问题的。中间其实改了很多次，就是没有改到点上，以后联系的时候，如果不是真错了，就不改，或者要保留原版的，不然没办法真正的找到错误。

如果考试中有这中情况，得把每个实现的点都列出来，然后逐个分析，不能一带而过，想一想真的是这样的吗？尤其是写if的时候的。而且不能只盯着一个点不看别的，浪费时间又找不到错误。

#### 完整代码

### 2022-06-2 寻宝！大冒险！ 使用map替换数组实现离散化索引

这题多亏了C++的STL，我们可以不去实现一些复杂的算法就可以直接求解。

#### 思路

如果我们直接用数组下标来索引，那么肯定会导致超出空间，因为空间复杂度是$10^9$ ，所以我们需要离散化的存储，离散化存储的方式的就有一个问题，如果我们不建立索引那么搜索一次的复杂度就是O(n) 那么最终的复杂度是$O(n^2)$很容易超时（我也没试，但是好像不会超时），所以我们使用了map建立索引，加快搜索速度。

然后怎么使用map呢？这也是我遇到的问题，详细看下面遇到的问题

#### 遇到的问题

1. 只使用了一维map

> ```c++
> map<int,int> bigp;
> 
> bigp[i]=j //就代表i，j点上有树
> ```
>
> 这样很容易就过了样例但是提交却只有10分
>
> ![image-20240308091031278](./%E6%80%BB%E7%BB%93.assets/image-20240308091031278.png)
>
> 相信大家一下就可以知道问题的所在了
>
> 我是先发现bigp[0] = 0这个式子不管0，0有没有树都成立，**这就导致了二义性，** 然后再一细想，那么一行中有多个数据的话就是bigp[1]=多个数，**这不是就被覆盖了吗？就是一行只存了一个数**，那样是不正确的
>
> 然后使用了
>
> ```c++
> map<int,map<int>>bigp;
> 
> bigp[i][j]=1 //就代表i,j点上有树
> ```
>
> 这样就不会出现上面二义性和数据覆盖的问题。
>
> 这样就可以100分了
>
> ![image-20240308091524899](./%E6%80%BB%E7%BB%93.assets/image-20240308091524899.png)

#### 完整代码

### 2022-06-3 角色授权 使用map优化索引+一些细节优化降低时间复杂度

这题目虽然看着长，但是题目的逻辑并不复杂，结构也挺清晰的，并且有也没有一些坑人的细节之类的，但是题目卡时间比较严重，而且最后竟然是用一个细节的优化方式才拿到了100分。

#### 题目重述

这个题的数据又三个方面

一个是角色。角色有唯一的名字，有操作类型（可以多个），有可操作资源类型（可以多个），有可操作资源名字（可以多个），这些都是使用字符串类型的存储的

第二个是用户和用户组 每个用户或者用户组都可以关联多个角色。用户和用户组都有唯一的名字

第三个是待授权的操作 这个包括用户 用户组 资源类型 资源名字

#### 思路

根据题目的数据，我们自然而然的就会想到针对每个用户/用户组存一个数组把对应的角色存下来，然后这样再判断角色是否有权限即可，这样搜索的效率就是logn（这就是建立索引的过程）

#### 遇到的问题（学习到的东西）

这次的写代码的过程，相较之前的曲折和困难，这次还是比较顺利的，写完第一次，过了用例，就直接拿到了70分。

![image-20240309134209391](./%E6%80%BB%E7%BB%93.assets/image-20240309134209391.png)

然后就想办法去优化。

1. 尝试再新建索引优化，失败

就是在根据用户/用户组索引到角色的列表之后再用操作来索引角色，就是在map里再加一层，但是最后发现直接超时超出内存限制了。

![image-20240309134526516](./%E6%80%BB%E7%BB%93.assets/image-20240309134526516.png)

2. 尝试使用scanf输入优化输入速度

但是本来想用scanf输入，但是发现用scanf输入字符串有点困难，因为scanf是c里面的c是没有封装好的string 的所以不能直接输入，失败

3. 使O2优化

本题的输入的数据比较多，所以考虑到优化输入，在使用scanf不行之后，突然想起来c++有自己的o2优化，就是在 前面加上三行

```c++
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    ……………………
	return 0;
}
```

这样就好了其他不用动

然后就可以拿到了90分![image-20240309135054865](./%E6%80%BB%E7%BB%93.assets/image-20240309135054865.png)

4. 之后又尝试了一些常数级别的优化 失败

就是使用++i而不是i++，使用set<int>整合角色，防止重复鉴权等，都失败的了，还是90分。

5. 参数类型问题

最后在一位博主的启发下，改变的传入函数的参数类型，就拿到了100

就是函数在进行只读操作时，**使用引用传递(const "type" &)比起直接传入参数效率更高。**

> ```c++
> bool check_all(struct behave t,unordered_set<int> s)
> {
>     ……
> }
> bool check_roler(struct behave t, int id)
> {
>     ……
> }
> ```
>
> 改为
>
> ```c++
> 
> bool check_roler(const struct behave &t, const int &id)
> {
>     ……
> }
> bool check_all(const struct behave &t,const unordered_set<int> &s)
> {
>    …………
> }
> ```

然后就直接时间大大缩短，拿到了100分

![image-20240309135754106](./%E6%80%BB%E7%BB%93.assets/image-20240309135754106.png)

最后也是没想到，csp考试竟然要卡你这种样的点，不让你过，不过还是学一学这些优化计划防止他再去考。

#### 完整代码

### 2022-03-2 出行计划 差分和前缀和

这题很久之前做过一次，现在已经基本忘记了，所以重新做一遍，然后一遍就过了，也算是有了一些进步了。

#### 思路

这题要是暴力的话时间复杂度是$O(n^2)$ 然后数据量是$10^5$ 那么总的时间就是$10^{10}$超过了1s，估计是会超时的，所以就想着如何优化一下。

他每次的区间查询，我们其实可以做下预处理，就是我们其实可以提前算出来所有的q能够满足出行计划的数量呢？因为计划已经确定了，不会再改变了。然后用q这个数组存起来。

那么如何提前算q呢？ 我们可以遍历每个出行计划，那么我们就可以知道在哪个区间内的q可以增加1个出行计划，然后如何进行整个区间的加减操作呢？使用差分复杂度是O(1)就可以。

最后根据输入的q在去除q数组的数即可也是O(1)

最终的时间复杂度也就是O(n)可以满足题目要求。

#### 遇到的问题（不小心出现的细节问题）

1. 没有搞清楚一个出行计划可行的做核酸的时间的区间

我原本以为可行的区间是t~t+c，后来发现是错误的，不是往前满足而是之前的才能满足

也就是区间是 t-c+1~t这个区间里的

2. 一些蠢错误

计算最大的时间（看q 的最大区间是啥）是这个

![image-20240310220449415](./%E6%80%BB%E7%BB%93.assets/image-20240310220449415.png)

而不是

![image-20240310220516003](./%E6%80%BB%E7%BB%93.assets/image-20240310220516003.png)



3. 没有注意到k的应用

做了核酸之后要等k 个时间单位，但是不影响，因为每个做的核酸都是要等k个单位，而且核酸的有效时间也是从k个单位之后才开始计算的。

![image-20240310220731937](./%E6%80%BB%E7%BB%93.assets/image-20240310220731937.png)

只需要在最后输出的时候加一个k即可

然后就可以100分了

![image-20240310220818602](./%E6%80%BB%E7%BB%93.assets/image-20240310220818602.png)

#### 完整代码

### 2022-03-3 计算资源调度器 stl大模拟使用map优化索引

在联系了之前那么多道stl大模拟题后，终于能够独自在一定的时间内完成第三题了，不过这题算是比较简单的，因为我是倒着练习的，先练习的是最新的题目，但是csp的趋势是，前2题越来越简单，然后第三题越来越难，所以我做的这题算是在第三题中比较简单的。

> ![image-20240311141304036](./%E6%80%BB%E7%BB%93.assets/image-20240311141304036.png)
>
> 从开始看题到100分

但是不管难度如何第三题的思路都是使用STL中的数据结构，并且没有什么算法的，然后就是注意一些细节问题就可以拿到满分，所以不要觉得第三题很难。

一是有信心，二是能想到对应的数据结构，三是能够注意细节。这样拿下第三题就不在话下（当然我还没有拿下）

#### 思路

这题的思路之前的题目都是大差不差的，看似题目的背景有些差别，但是思路非常相似。

首先题目有四个数据类型

一是可用区：可用区可以包含多个计算节点，每个可用区有唯一的编号

二是计算节点：计算节点是包含在可用区里的，每个计算节点含有多个应用

三是应用：就是包含在计算节点中的，每个计算任务都要有一个应用执行

四是计算任务：计算任务可以有一些需求来限制要放在哪个可用区，哪个计算节点上的。

然后每个我们就可以使用map来建立映射关系（本质上是建立索引方便搜索的）

最后任务就是为任务搜索出符合限制条件的计算节点，然后输出就好了。

#### 写代码的过程（遇到的问题）

首先做第三题最好不要一口吃一个胖子，就是一步一步的写，一个一个测试点的过，这样找错误比较容易。如果全部写完然后再找错误很容易会被混淆，很难定位错误在哪里。

**只有vector不可以直接按值删除**

1. 首先不考虑限制条件（对应测试点1，2，3，4）

主要就是排序问题 按着题目给的排序要求来写，选出来最合适的计算节点然后更新

这里我写完了还是0分

![image-20240311143452125](./%E6%80%BB%E7%BB%93.assets/image-20240311143452125.png)

然后发现最后选出来了最适合的节点，但是没有更新它，让其包含这个计算任务

然后就20分了

![image-20240311143953503](./%E6%80%BB%E7%BB%93.assets/image-20240311143953503.png)

2. 然后考虑有可用区亲和性的限制（对应测试点 5，6，7，8，9，10）

这里写好了代码，但是还是20分

![image-20240311144426559](./%E6%80%BB%E7%BB%93.assets/image-20240311144426559.png)

然后检查错误，发现是没有判断特殊情况，如果可用区没有节点可分配的情况下就输出0

```c++
            if (na != 0) // 如果有可用区亲和性
            {
                alloc = part[na].nodein;
                alloc_part.insert(na);
                if (alloc.empty())
                {
                    cout << 0 << ' ';
                    continue;
                }
                have_app = part[na].app_to_node[paa];
            }
```

之后就50分了

![image-20240311144723011](./%E6%80%BB%E7%BB%93.assets/image-20240311144723011.png)

3. 然后写有节点反亲和性限制的代码（对应测试点11，12，13，14，15，16）

这个比较麻烦，写的时候发现代码结构有问题重构了结构（就是if else的结构），发现还是50分

![image-20240311145121698](./%E6%80%BB%E7%BB%93.assets/image-20240311145121698.png)

然后发现代码有漏洞，就是如果根据这个反亲和性搜索出来的节点的集合是空的，那么如果是强制必须满足的话就要输出0然后跳出本次循环，但是如果不是强制满足的话，就不用这个条件删除，还用原来的。

**这里我只判断了不是空的情况下，和是空并且强制满足的情况**

```c++
if (!temp.empty())
    alloc = temp;
else if (temp.empty() && paa == 1) // 如果要强制满足 但是又为空
{
    cout << 0 << ' ';
    continue;
}
                
```

这点看了我好久，很不容易发现，写代码不够规范，思路不够清晰导致的。

然后改成这样就好了

```c++
                if (temp.empty() && paa == 1) // 如果要强制满足 但是又为空
                {
                    cout << 0 << ' ';
                    continue;
                }
                if (!temp.empty())
                    alloc = temp;
```

然后还是50分，然后自己编了数据也没发现问题，**后来就重新读题**，发现原来是判断paar是不是必须满足，我笔误了一下，就找了很久的bug

> 将paa改成了paar
>
> ```c++
> if (temp.empty() && paa == 1) 
> ```
>
> 改成了
>
> ```c++
> if (temp.empty() && paar == 1) 
> ```
>
> 

然后就80分了，拼写错误真的很坑啊，很浪费时间啊，以后写if条件的时候要多想一下

![image-20240311145857716](./%E6%80%BB%E7%BB%93.assets/image-20240311145857716.png)

4. 增加应用亲和性的限制

**这个限制，一开始读题没发现后来才发现是同一个区内要有相同的应用，而不是同一个计算节点上**

然后这次写的比较顺利，把前面所有的问题都注意到了

一下就100分了

![image-20240311150320159](./%E6%80%BB%E7%BB%93.assets/image-20240311150320159.png)

#### 完整代码

### 2021-12-2 序列查询新解 分段处理 用乘法代替加法减少时间复杂度（思想是离散化）

这个题目挺有意思，比之前几年我做过的都要有些难，但是也不是难吧，就是没有见过这种的，然后就想不到怎么去优化时间复杂度。

一开始我以为题目的优化思路是预处理，就是提前算好f和g然后再减在一起算出sum，我还抱着侥幸心理，以为$10^9$的复杂度不会超时，但是最后还是超时了，此时我就是黔驴技穷了，我只是想到在$10^9$的基础上优化，但是没有想到怎么用直接使用$10^5$分段进行计算。然后看了别人的思路才有了思路。希望考试不要出现这种情况，因为考试可没有别人的思路给你看。

#### 思路

这题的思路不同于之前的第二题，实用什么的差分啊，什么二分搜索啊，什么动态规划啊都没有使用到。而是不同寻常的使用了分段的思想。

我一开始的想法是使用一个数组把f全部算出来，但是发现并不行会超时，并且也没有用空间来换取时间，但是其中有很多重复的加法，可以用乘法替换。

我们拿到一个问题一般是要将问题规约成更小的问题，那么如何规约就会导致问题的时间复杂度和空间复杂度不同，这题你要是想用空间换时间（就是把临时搜索的数据存储下来，后边可以不搜索直接使用的思想）不太行，而是要减少计算的次数，基本就是将加换成乘。

那么怎么将加换成乘呢？就是将相同的加合并，对应这个题目就是算f和g的时候，**我们可以把一段区间内的加变成一次乘法。** 那么这个区间就是当g和f 相同的区间，g的变化是有规律的，f 的变化也是有规律的，我们就是判断一个区间是不是f和g都不变化那么我们就可以直接加上区间长度和$|f-g|$​的乘积 。

#### 解题过程

1. 我首先就是按照我想的那种思路写了一种代码，直接就70分了，剩下全部超时了

![image-20240313155609644](./%E6%80%BB%E7%BB%93.assets/image-20240313155609644.png)

2. 然后我就想找一种优化的方法，比如使用常数级优化，O2优化等，全都是超时，可以发现只要 复杂度是$10^9$​怎么优化也没有用的。

   测试只有一个for循环$10^9$次什么也不干，就会超时

   ![image-20240313155759441](./%E6%80%BB%E7%BB%93.assets/image-20240313155759441.png)

3. 然后看了别人的思路，说使用分段的思想，我瞬间就明白了，就写代码

![image-20240313160013763](./%E6%80%BB%E7%BB%93.assets/image-20240313160013763.png)

但是发现错误不太行，原来是没有使用long long

改用了long long 后就可以了

![image-20240313160147247](./%E6%80%BB%E7%BB%93.assets/image-20240313160147247.png)

#### 超时的完整代码



#### 100分的完整代码

### 2021-12-3 登机牌条码 大模拟 字符串处理+模拟数学运算（多项式除法）

做完一题回过来再看发现也不是做的时候觉得那么难，但是当时就是像傻子了一样，不会变通，想不到该怎么做。和碰到那个梯度下降的那道题一样，就蒙圈了找不到思路。以后碰到了模拟数学运算的题目，不是什么找数列找规律，就是简单的模拟手动计算，手动怎么计算，那么代码就怎么写。

然后看了别人的思路才会写，考试当然没有别人的思路可以看呢，那考试怎么办呢？

#### 思路

这个题目分为两大部分，一部分是字符串处理，另一部分是模拟数学运算

1. 字符串处理

字符串处理其实并不难，虽然不难自己写出来了，但是找bug还是花了很长时间的。

字符串处理主要就是按照题目给的，将输入的字符串处理加工，然后转换成对应的数字，没有什么难理解的。

2. 模拟数学运算

模拟数学运算就是使用代码模拟这个的过程

![665843df0b8c4880b3fab28919f99721](./%E6%80%BB%E7%BB%93.assets/665843df0b8c4880b3fab28919f99721.png)

就是遍历消除d（x）的k+1项到最后一项，那么最后k项的系数取反再取模就是所求的c

但是g(x)怎么求呢？肯定还是模拟手动啊。

循环遍历k次，每次乘以一个式子。

怎么乘呢？**每个式子都有一个x和一个常数，乘以x就是左移一位，就是开头添加一个0，常数就是每个系数都乘以这个常数**  就是这样。

#### 实现过程（遇到的问题）

1. 首先是对字符串处理中遇到的问题

   1. 写判断语句出错

   > 原本的
   >
   > ```c++
   >     if (a >= '0 && a <= '9')
   >         to_state = 2;
   >     if (a <= 'Z' && a >= 'A')
   >         to_state = 3;
   >     if (a <= '0' && a >= '9')
   >         to_state = 1;
   > ```
   >
   > 改过的
   >
   > ```c++
   >     if (a >= '0' && a <= '9')
   >         to_state = 2;
   >     if (a <= 'Z' && a >= 'A')
   >         to_state = 3;
   >     if (a <= 'z' && a >= 'a')
   >         to_state = 1;
   > ```
   >
   > 写的时候没按顺序写果然会出错，然后debug 才看到的，应该先检查下代码有没有问题再去debug 的

   

2. 初始状态没有搞清楚

   ![image-20240314170259555](./%E6%80%BB%E7%BB%93.assets/image-20240314170259555.png)

   没有注意到这句话，还以为是一开始是啥初始状态就是啥呢。

3. 数据字段的开头有一个长度的数据

   这个数据我一开始没有主要到，还以为是输入的字符串的长度是多少就是多少呢，原来是在计算完转换成那个什么码后在看code_word有多长（包括他自己）

   ![image-20240314170914764](./%E6%80%BB%E7%BB%93.assets/image-20240314170914764.png)

   改完这3个bug就可以拿到40分了

![image-20240314170421894](./%E6%80%BB%E7%BB%93.assets/image-20240314170421894.png)

4. 接下来就是模拟多项式除法的过程了（计算校验码的过程）

看了别人的思路后，再写就没有再出错了，只是在取模的问题上有点问题

> 一开始只在结尾处取模
>
> ```c++
>         for (int i = k - 1; i >= 0; i--)
>         {
>             int temp = (-1 * d[i]) % 929;
>             code_word.push_back(temp >= 0 ? temp : temp + 929);
>         }
> ```
>
> 但是发现并不行只能拿到50分
>
> ![image-20240314171315622](./%E6%80%BB%E7%BB%93.assets/image-20240314171315622.png)
>
> 然后我又在计算g(x) 计算d(x)的过程中取余
>
> ```c++
>         for (int i = 2; i <= k; i++)
>         {
>             vector<int> temp = g;
>             g.insert(g.begin(), 0);
>             for (int i = 0; i < temp.size(); i++)
>             {
>                 g[i] = (temp[i] * three) % 929 + g[i] % 929;
>                 g[i] % 929;
>             }
>             three = (three * 3);
>         }
> ……
> ……
>             for (int i = d.size() - 1; i >= k; i--)
>         {
>             int temp = -1 * d[i];
>             d[i] = 0;
>             for (int j = g.size() - 2; j >= 0; j--)
>             {
>                 d[i - (g.size() - 1 - j)] = (g[j] * temp) % 929 + d[i - (g.size() - 1 - j)] % 929;
>                 d[i - (g.size() - 1 - j)] %= 929;
>             }
>         }
> ```
>
> 然后就拿到了80分
>
> ![image-20240314171546939](./%E6%80%BB%E7%BB%93.assets/image-20240314171546939.png)
>
> 之后再对three变量取模才100分
>
> ```c++
>         for (int i = 2; i <= k; i++)
>         {
>             vector<int> temp = g;
>             g.insert(g.begin(), 0);
>             for (int i = 0; i < temp.size(); i++)
>             {
>                 g[i] = (temp[i] * three) % 929 + g[i] % 929;
>                 g[i] % 929;
>             }
>             three = (three * 3) % 929;
>         }
> ```
>
> ![image-20240314171639600](./%E6%80%BB%E7%BB%93.assets/image-20240314171639600.png)

#### 完整代码



##  数组

### 【深基5.例7】工艺品制作 | P5729

第一次错误：范围1< w,x,h <= 20数组大小设置错误设置为了20所以会有RE(RuntimeError)

### [AHOI2001] 彩票摇奖 | P2550

第一次暴力实现4ms暴力实现
其实可以使用号码作为分数下标这样可以快速查找到是否是中奖号码。

第二次用号码作为下标 仍然是4ms改进不大，但是第二次写
把

```C++
int **a=new int *[n];
cin>>n;
```

顺序写反了导致一直RE很难找到错误

### P5730 【深基5.例10】显示屏

看题不仔细，输入输出的格式要仔细看
输出的是大写的X并且其中没有空格，要仔细看
本题没有什么难度和算法

### 梦中的统计 | P1554

一次过

#### 学到新知识：stoi、to_string

![Alt text](image.png)
注意：

1. std::to_string()有9种重载形式，分别对应int/long /long long/unsigned/unsigned long/unsigned long long/float/double/long double。
2. b默认值为10，即10进制；若b = 0，则表示自动确定string序列的基数，如0x7f会自动以16进制为基数。
3. 对于转换为浮点型的字符串(上述表格的最后3个)，可以识别小数点和指数e、E，如std::stod(".3e3")结果为300。
**to_string**例子：

```c++
std::string pi = "pi is " + std::to_string(3.1415926);
std::string perfect = std::to_string(1 + 2 + 4 + 7 + 14) + " is a perfect number";
std::cout << pi << '\n';
std::cout << perfect << '\n';
```

结果：
![At text](image-1.png)
**stoi**例子

```c++
std::string str_dec = "2001, A Space Odyssey";
std::string str_hex = "40c3";
std::string str_bin = "-10010110001";
std::string str_auto = "0x7f";

std::string::size_type sz;   // alias of size_t

//1.转换基数为10进制，sz保存','下标，i_dec = 2001
int i_dec = std::stoi(str_dec, &sz);
//2.转换基数为16进制。所以i_hex = 0x40c3,十进制为16579
int i_hex = std::stoi(str_hex, nullptr, 16);
//3.转换基数为2进制。所以i_bin = -10010110001B,十进制为-1201
int i_bin = std::stoi(str_bin, nullptr, 2);
//4.自动确定 转换基数
int i_auto = std::stoi(str_auto, nullptr, 0);

std::cout << str_dec << ": " << i_dec << " and [" << str_dec.substr(sz) << "]\n";
std::cout << str_hex << ": " << i_hex << '\n';
std::cout << str_bin << ": " << i_bin << '\n';
std::cout << str_auto << ": " << i_auto << '\n';
```

结果：
![Alt text](image-2.png)

### [NOIP2014 普及组] 珠心算测验 | P2141

第一遍过：使用了debug调试发现有一步没有包含在if大括号中间，发现修改后通过
时间复杂度O（3）

可以发现求一个数能否被其他数求和时，每求一个数就要算以下所有其他数能求和出来的数，导致了很多重复的运算

stl set集合使用方法()
集合和

其他方法
优化时间复杂度
使用stl中的集合

### 爱与愁的心痛 | [P1614](https://www.luogu.com.cn/problem/P1614)

第一遍过 ：使用暴力复杂度为O(n*2) 其中有不少重复的运算

求区间的和用前缀和数组来减少时间复杂度

第二遍：使用前缀和数组 ，不过前缀和数组的大小设置的要比原数组的大小大1

例子： 

```c++
    int *a=new int [n+1];
    a[0]=0;//初始化使用前缀和第一个元素为0
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[i]=a[i-1]+a[i];//前缀和实现
    }
```



### 【Mc生存】插火把 | [P1789](https://www.luogu.com.cn/problem/P1789)

第一遍交失败 **数组大小设置没有根据题目的数据范围来设置**

**数组循环的for的条件设置的有问题** 注意for的终止条件

变量命名不要重复尤其是 	i,j,k等

### [USACO1.2] 方块转换 Transformations | [P1205](https://www.luogu.com.cn/problem/P1205)

第一遍交失败：判断if时候条件写错，多种情况混合在了一起，这个不满足时那个可能满足，有一个不满足应该都否定了，但是这样写后，导致互补一会这种情况满足，一会另一种情况满足 **最后好像满足了，实际上都不满足，注意一票否决的情况**

第二遍失败 ：模拟出错注意耐心审题，不能一概而论想像**要实际在脑子中或者手写模拟一下**

## 搜索

### [USACO11OPEN] Corn Maze S | [P1825](https://www.luogu.com.cn/problem/P1825) BFS

这题主要就是坑点比较多，写代码并不复杂，算法也不复杂。

首先一看题目DFS（深度优先搜索）好像可以，因为DFS就是模拟奶牛往下走的过程嘛，也不难写然后就有了第一版的代码：

```c++
#include <bits/stdc++.h>
using namespace std;
int N, M;
struct point
{
    int i, j;
};
char place[301][301];
map<char, list<struct point> > transit;
bool path[301][301];
int min_time = 999999;
int start_i, start_j, end_i, end_j;
bool dfs(int count, int i, int j)
{
    // cout << count << ' ' << place[i][j] << ' ' << i << ' ' << j << endl;
    if (place[i][j] == '#' || path[i][j])
    {
        return false;
    }
    if (i == end_i && j == end_j)
    {
        min_time = min(count, min_time);
        return true;
    }
    path[i][j] = true;
    if (place[i][j] >= 'A' && place[i][j] <= 'Z')
    {

        list<struct point>::iterator it1 = transit[place[i][j]].begin();
        for (; it1 != transit[place[i][j]].end(); it1++)
        {
            if ((*it1).i != i && (*it1).j != j)
                dfs(count, (*it1).i, (*it1).j);
        }
    }
    dfs(count + 1, i, j - 1);
    dfs(count + 1, i, j + 1);
    dfs(count + 1, i - 1, j);
    dfs(count + 1, i + 1, j);
    path[i][j] = false;
    return false;
}
int main()
{
    cin >> N >> M;
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= M; j++)
        {
            cin >> place[i][j];
            if (place[i][j] == '@')
            {
                start_i = i;
                start_j = j;
            }
            if (place[i][j] == '=')
            {
                end_i = i;
                end_j = j;
            }
            if (place[i][j] >= 'A' && place[i][j] <= 'Z')
            {
                struct point p = {i, j};
                transit[place[i][j]].insert(transit[place[i][j]].end(), p);
            }
        }
    }
    dfs(0, start_i, start_j);
    cout << min_time;
    return 0;
}
```

![image-20230916104605799](./%E6%80%BB%E7%BB%93.assets/image-20230916104605799.png)

然后就只拿了12分，奇怪了，为什么会这样，明明就是按照题目写的，还有一堆TLE的，索性先不管TLE的先把WA的处理了。

然后发现了第一个bug

```c++
            if ((*it1).i != i && (*it1).j != j)
                dfs(count, (*it1).i, (*it1).j);
```

这里的判断条件写错了，不应该是两个都不相同才转移，（为啥经常犯这种低级错误呢？还特别难找）

改过之后

```c++
            if ((*it1).i != i || (*it1).j != j)
                dfs(count, (*it1).i, (*it1).j);
```

然后结果

![image-20230916105046883](./%E6%80%BB%E7%BB%93.assets/image-20230916105046883.png)

为什么会这样呢？

再去审题就会发现一个**想当然的地方**

> 如果一头奶牛处在这个装置的起点或者终点，这头奶牛就**必须**使用这个装置。

还以为还是可以选择传送或者转移呢，原来是必须要传送啊

此时我又陷入了迷茫，必须要转移的话那是不是会导致一直循环转移啊？还是只能转移一次吗？

然后我无奈之下看了题解

为啥全是BFS（广度优先搜索）啊？？肯定是互相抄的结果，我偏不信邪，就要用DFS来写。

不过还是有收获的可以直接让那个转移，在本层转移

```c++
bool dfs(int count, int i, int j)
{
    if (place[i][j] == '=')
    {
        min_time = min(count, min_time);
        return true;
    }
    if (i > N || i < 1 || j > M || j < 1 || path[i][j] || place[i][j] == '#')
    {
        return false; // 不满足条件直接回溯
    }
    path[i][j] = true; // 初始化条件
    if (place[i][j] >= 'A' && place[i][j] <= 'Z')
    {
        list<struct point>::iterator it1 = transit[place[i][j]].begin();
        for (; it1 != transit[place[i][j]].end(); it1++)
        {
            if ((*it1).i != i || (*it1).j != j)
            {
                i = (*it1).i;
                j = (*it1).j;
                break;
            }
        }
    }
    dfs(count + 1, i + 1, j );
    dfs(count + 1, i - 1, j);
    dfs(count + 1, i, j - 1);
    dfs(count + 1, i, j + 1);
    path[i][j] = false; // 恢复状态
    return false;
}
```

这样不就好了

结果

![image-20230916105806902](./%E6%80%BB%E7%BB%93.assets/image-20230916105806902.png)

为啥还是这样啊？还有WA的啊？

然后我又左思右想，是不是初始化的点不太对啊？回复状态的点也不太对啊？

确实是这样的，我们转移状态后恢复的状态应该是最一开始的点的状态，而不是那个传送点的状态。

至于为什么传送后的点的状态不用的初始化和恢复，因为这个点后边还可以转回来使用

```c++
bool dfs(int count, int i, int j)
{
    int init_i = i, init_j = j;
    if (place[i][j] == '=')
    {
        min_time = min(count, min_time);
        return true;
    }
    if (i > N || i < 1 || j > M || j < 1 || path[i][j] || place[i][j] == '#')
    {
        return false; // 不满足条件直接回溯
    }
    if (place[i][j] >= 'A' && place[i][j] <= 'Z')
    {
        list<struct point>::iterator it1 = transit[place[i][j]].begin();
        for (; it1 != transit[place[i][j]].end(); it1++)
        {
            if ((*it1).i != i || (*it1).j != j)
            {
                i = (*it1).i;
                j = (*it1).j;
                break;
            }
        }
    }
    path[init_i][init_j]=true;  
    if (i + 1 >= 1 && i + 1 <= N && j >= 1 && j <= M && !path[i + 1][j] && place[i + 1][j] != '#')
        dfs(count + 1, i + 1, j);
    if (i - 1 >= 1 && i - 1 <= N && j >= 1 && j <= M && !path[i - 1][j] && place[i - 1][j] != '#')
        dfs(count + 1, i - 1, j);
    if (i >= 1 && i <= N && j - 1 >= 1 && j - 1 <= M && !path[i][j - 1] && place[i][j - 1] != '#')
        dfs(count + 1, i, j - 1);
    if (i >= 1 && i <= N && j + 1 >= 1 && j + 1 <= M && !path[i][j + 1] && place[i][j + 1] != '#')
        dfs(count + 1, i, j + 1);
    path[init_i][init_j] = false; // 恢复状态
    return false;
}
```

我顺便还剪了剪枝

结果

![image-20230916110314903](./%E6%80%BB%E7%BB%93.assets/image-20230916110314903.png)

唉无能为力的，只能放弃DFS了，而且再剪枝也减不了了，因为DFS进行了许多重复运算，要是

我会**记忆深度优先搜索**就好了，那样减少了重复运算没准就可以了。

然后只能转战BFS了

一不小心又出了个错 就是第47行多写的一个等于号，导致只对了37分，改过来后下全对

```c++
#include <bits/stdc++.h>
using namespace std;
int N, M;
struct point
{
    int i, j, c;
};
char place[301][301];
map<char, list<struct point> > transit;
bool path[301][301];
int min_time = 1 << 20;
int temp[4] = {1, 0, -1, 0};
int temp2[4] = {0, 1, 0, -1};
int start_i, start_j;
queue<point> q;

int bfs()
{
    q.push((struct point){start_i, start_j});
    struct point p;
    while (!q.empty())
    {
        p = q.front();
        q.pop();
        if (place[p.i][p.j] == '=')
        {
            return p.c;
        }
        if (place[p.i][p.j] >= 'A' && place[p.i][p.j] <= 'Z')
        {
            list<struct point>::iterator it1 = transit[place[p.i][p.j]].begin();
            for (; it1 != transit[place[p.i][p.j]].end(); it1++)
            {
                if ((*it1).i != p.i || (*it1).j != p.j)
                {
                    p.i = (*it1).i;
                    p.j = (*it1).j;
                    break;
                }
            }
        }
        for (int i = 0; i < 4; i++)
        {
            int x = p.i + temp[i], y = p.j + temp2[i];
            if (place[x][y] != '#' && !path[x][y] && x >= 1 && x <= N && y >= 1 && y <= M)
            {
                path[x][y] = true;
                q.push((point){x, y, p.c + 1});
            }
        }
    }
    return -1;
}
int main()
{
    cin >> N >> M;
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= M; j++)
        {
            cin >> place[i][j];
            if (place[i][j] == '@')
            {
                start_i = i;
                start_j = j;
            }
            else if (place[i][j] >= 'A' && place[i][j] <= 'Z')
            {
                struct point p = {i, j, 0};
                transit[place[i][j]].push_back(p);
            }
        }
    }
    cout << bfs();
    return 0;
}
```

结果：

![image-20230916110810138](./%E6%80%BB%E7%BB%93.assets/image-20230916110810138.png)

#### 总结

这题不难考的就是审题和BFS的书写。

我主要就是老卡在一些审题和小细节的bug 上什么时候我才能养成不出小bug 的能力，和快速检查出bug的能力，其次就是审题要仔细一些，看清楚一些细节再写题。

###　马的遍历 | [P1443](https://www.luogu.com.cn/problem/P1443)　BFS

这题基本上算是宽度优先搜索的模板题了，难度不是很大，只要看好特殊情况，编程少出一些小bug就好了

1. 第一个错误是：没有判断数据越界的情况，
2. 第二个错误是：队列的push应该写在if里
3. 第三个错误是判断越界的情况if的判断范围写错了
4. 第四个错误情况是特殊情况没有考虑正确

最后也是两遍才过，时间也不短，希望以后吸取教训

### [USACO08FEB] Meteor Shower S | [P2895](https://www.luogu.com.cn/problem/P2895) 宽度优先搜索 BFS

只要看到和路径相关的和步数相关的就基本上就是BFS了

这题的难点在于搜索过程中模拟陨石下落的过程，也就是实时更新哪些点可以走，哪些点不能走

1. 忘记了陨石一下要砸四个点
2. 忘记判断数组越界情况
3. 读题没有发现只要走出了300就安全了（看了题解才知道）

总结就是有bug 改不出来一定要仔细读题

### 迷宫 | [P1605](https://www.luogu.com.cn/problem/P1605) DFS 深度优先搜索

这题是经典的深度优先搜索

有几个要注意的点

1. 注意边界的问题，判断是否超出了边界
2. 注意恢复状态问题，向下一层遍历后要恢复状态

然后搞完这些发现才70分，然后找不出bug了，,,,

找好久才发现是，原来起点没有初始化path，也就是没有把起点当成已经走过的点。

以后不要再犯这种错误了，很容易犯，犯了还很难找。

### 单词方阵 | [P1101](https://www.luogu.com.cn/problem/P1101)经典搜索深度优先搜索

这题是经典的深度优先搜索，但是要有一定的编程思想，这样才能减少代码量，防止写的又臭又长的代码

首先看到那种矩阵的上下左右的时候，首先要想到用数组来存x,y的移动量

就像这样：

```c++
int x_change[] = {1, 0, -1, 0, 1, -1, 1, -1};
int y_change[] = {0, 1, 0, -1, 1, -1, -1, 1};
```

然后是使用for循环来遍历这样会方便很多很多减少很多重复代码

然后就是这个深度优先搜索的函数，尽量写的能够复用，不要一个方向写一个那样代码又臭又长

```c++
bool findword(int i, int j, int di, int dj, int next)//i，j表示当前坐标，di,dj分别表示移动的方向，next表示要匹配的字符串的下一个
{
    if (next >= 7)
    {
        return true;
    }
    if (i + di >= 0 && i + di < n && j + dj >= 0 && j + dj < n && martx[i + di][j + dj] == word[next])
    {
        if (findword(i + di, j + dj, di, dj, next + 1))
        {
            isword[i + di][j + dj] = true;
            return 1;
        }
    }
    return 0;
}
```

然后其他的就没有什么了。

### [USACO10OCT] Lake Counting S | [P1596](https://www.luogu.com.cn/problem/P1596) 深度优先搜索

这题要是找对思路代码并不难，甚至能一遍过，但是要是找不对思路就会陷入无穷的bug找也找不出来

一开始我是并没有想到用深度优先搜索的，因为我考虑到题目仅仅只是考虑周围的水坑，那就只要判断周围的有没有水坑就好了，要是有就是属于联通的水坑那么水坑的数量就不加一，然后最一开始就是如果周围没有检测出来的水坑那么久加一，然后从左到右，从上到下就开始遍历就好了。

但是这样最多拿到40分，然后我百思不得其解，为什么会这样，问了朋友也是对于我这算法有些迷惑，最终只能下载题解。

下载题解方向原来是我那种算法有漏洞，**就是有的水坑是通过下面的水坑联通在一起的**，然后我那种遍历顺序是遍历不到下面的，所以有问题，导致水坑数量增加

最后直接用DFS一遍就过了。



##  前缀和、差分与离散化

### 最大加权矩形 | [P1719](https://www.luogu.com.cn/problem/P1719)

**思路：**使用二维前缀和数组来求解，这样求解二维数组中的片段（子矩阵）的和更加节省时间，然后通过遍历所有子矩阵求出和最大的子矩阵

这题必须写下题解，写了好久找了好久的bug，如果你也卡了很久找不到bug可以看看我的找bug的旅程。

### [NOIP2011 提高组] 聪明的质监员 | [P1314](https://www.luogu.com.cn/problem/P1314)

####　题目

[**题目链接**](https://www.luogu.com.cn/problem/P1314)

####  读题

首先读题大家肯定没有问题，但是我不知道大家有没有注意到一个情况，就是题目给的样例中，矿物是按重量排序大小排序的，就是这一点把我坑惨了，还以为其他测试数据也是如此，就直接默认是有序的然后进行二分搜索发现，一个AC也没有。

> # 样例
> ## **输入**
> ````c++ 
> 5 3 15  
> 1 5 
> 2 5 
> 3 5 
> 4 5 
> 5 5 
> 1 5 
> 2 4 
> 3 3 
> ````
> ## **输出**
> ```c++
> 10
> ````
>

#### 思路

**首先**你可以读题发现，直接通过他给的思路模拟，就是一种办法，本着暴力也是一种解法的态度，写下了第一版代码，就是完全按着题目的介绍来模拟。第一版发现了题目完全可以离散化，就是搜索的时候解的空间是 **符合W标准矿物的个数** ，搜索的时候就遍历这个个数就可以找到最佳答案
![在这里插入图片描述](https://img-blog.csdnimg.cn/96cb09921ac04578b9b9eea783e7414f.png)

**然后**发现可以用二分搜索来优化搜索。
**二分搜索的使用条件一定有一个是 搜索空间是有序的**，这样才能使用二分搜索，所以我**又另开了一个数组**，来存储这个有序的矿物的信息。那为什么要重新开一个数组呢？不是纯纯浪费空间吗？**不！当然不是**，因为题目已经给矿物编好序号了，**如果我打乱重新排序，就会导致后面根据区间来算y就会出错**，这也是非常容易忽略的一点，在很多题目中也容易忽略这一点。
![当时真崩溃](https://img-blog.csdnimg.cn/393a5d83313243a9b48f70922685d9ff.png)
忽略那一点导致AC的还不如之前模拟的，然后才发现那个问题
![离AC又进了一步](https://img-blog.csdnimg.cn/b0d1d3f2034e4a5b835c6ae841b716a1.png)
最后又突然发现这种因为题目有**重叠区间的反复相加求和的操作**，这就构成了使用前缀和数组的前提条件，然后使用前缀和可以只进行一次求前缀和数组的操作，**再求区间的和就只用收尾相减就可以求出区间的和** 大大节省了时间。
![在这里插入图片描述](https://img-blog.csdnimg.cn/4fa75b5306b84aa681f858f26a00eac9.png)
竟然还有一个错，然后仔细检查才发现 是二分搜索的循环判断条件写错了应该是 **>=**
最终可歌可泣终于AC了
![在这里插入图片描述](https://img-blog.csdnimg.cn/326b3d374b144559988d07ee310ad0ee.png)



#### **总结**

算法题就是要多动手，多自己手写，会发现各种各样的问题，只有通过这些问题才能不断进步，不然只是纸上谈兵，空有理论。
算法题还是挺有意思的，要发现其中的乐趣，动力不就源源不断的来了嘛

### 语文成绩 | [P2367](https://www.luogu.com.cn/problem/P2367)

差分数组的基本使用，当有重复对区间操作（加减）的可以使用差分操作。

容易错的bug

```c++
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        a[i]=a[i]-a[i-1];//这里出错了这样构建的差分数组是不对的
        //导致我一直找不到bug 吐了
        //所以还是重新建一个数组为好
    }
```

转换成原数组时容易出的错误

```c++
    for (int i = 1; i <= n; i++)
    {
        a[i]=a[i-1]+b[i];//这里也容易出错如果不更新a[i]则会导致后续结果出错
        mini = min(a[i], mini);
    }
```

### 地毯 | [P3397](https://www.luogu.com.cn/problem/P3397)

经典的二维差分数组的题目，可以用作练手，回顾二维差分数组的核心操作，指定区间的加减，使用O（1）的复杂度。

### [NOI2015] 程序自动分析 | [P1955](https://www.luogu.com.cn/problem/P1955) 并查集+离散化

经典并查集+离散化

#### 离散化的三步：

**1.去重（可以用到unique去重函数）**

**2.排序**

**3.二分索引（可以用到lower_bound函数）**

#### 并查集的操作：

查询、融合、初始化

#### 代码	

```c++
#include <bits/stdc++.h>
using namespace std;
int pre[1000007], book[1000007 * 3];
struct node
{
    int a, b, e;
};
struct node ne[1000001];
int find(int x)
{
    if (pre[x] != x)
        return pre[x] = find(pre[x]);
    return x;
} // 并查集查询
void join(int x, int y)
{
    pre[find(y)] = find(x);
} // 并查集融合
inline void first(int kkk)
{
    for (int i = 0; i <= kkk; i++)
        pre[i] = i;
} // 初 始 化
bool cmp(node a, node b)
{
    return a.e > b.e;
}
int main()
{
    int t;
    cin >> t;
    for (int j = 0; j < t; j++)
    {
        memset(book,0,sizeof(book));
        memset(ne,0,sizeof(ne));
        memset(pre,0,sizeof(pre));
        int n, pol = -1;
        cin >> n;
        bool flag = false;
        for (int i = 1; i <= n; i++)
        {
            int a, b, e;
            cin >> ne[i].a >> ne[i].b >> ne[i].e;
            book[++pol] = ne[i].a;
            book[++pol] = ne[i].b;
        }
        sort(book, book + pol + 1);
        int uni = unique(book, book + pol + 1) - book;
        first(uni); // 初始化pre数组  注意这里初始化的大小要根据有多少个不同数来初始化，这里卡了半天，因为这个是根据离散化后的最大数值来的，最大数值就是uni
        for (int i = 1; i <= n; i++)
        {
            ne[i].a = lower_bound(book, book + uni, ne[i].a) - book;
            ne[i].b = lower_bound(book, book + uni, ne[i].b) - book;
        }
        sort(ne + 1, ne + 1 + n, cmp);
        for (int i = 1; i <= n; i++)
        {
            int p1 = find(ne[i].a);
            int p2 = find(ne[i].b);
            if (ne[i].e) // 如果相等的话，就让两者合并入一个集合，如果在同一个集合中也不影响
            {
                pre[p1]=p2;
            }
            else
            { // 如果不相等的话判断是不是在一个集合中如果是则不满足条件
                if (p1 == p2)
                {
                    flag = true;
                    break;
                }
            }
        }
        if (flag)
        {
            cout << "NO" << endl;
        }
        else
            cout << "YES" << endl;
    }
    return 0;
}
```

### 领地选择 | [P2004](https://www.luogu.com.cn/problem/P2004)

求最优解之前，初始化的不能是自己任意设计的最小值，而是要从可行解中找到任意一个解，这样在比较中才能求到是可行解之中的，不然可能会出现不在可行解的范围内。

```c++
    int value=m[1+C-1][1+C-1]-m[1+C-1][1-1]-m[1-1][1+C-1]+m[1-1][1-1];//初始化 
//不行初始化为 int value=-1<<25  虽然已经小了但是不是可行解范围内的导致最后求出来的解不是可行解
    int x=1,y=1;//同样使用可行解
```

### 填涂颜色 | P1162

这题是需要稍微拐个弯才能做出来的，但是我就很难自己拐个弯然后做出来

这题要求是要一个找到一个被围着在一圈里的全部零，但是要找到这个被围着的圈很难，因为是dfs然后只能找到这圈但是不能同时对这个圈的所有元素进行赋值为2,如果这样的话，需要先找到那个圈，也就是需要dfs找需要找到一个连通分量上下左右都有1,这样确实很难很难，而且遍历的话时间复杂度也会比较高，原因是有很多重复运算。

但是当我们稍微拐个弯，反过来想，我们只要找到哪些周围是是边界的0不就可以了吗，就是把边界的0的联通分量通过深度优先或者宽度优先遍历出来这个通量然后打上标签这样剩下的不就是周围都是0的可以赋值为2了吗？

要说深度优先，宽度优先搜索我们肯定都会但是这题却又很容易卡住，这就是我们不能把问题转换为我们容易解决的，可以解决的问题。其次就是我们不能找到问题的关键，就是我们解决一个问题就是不仅要有一般的算法思想，我们还有有针对每个题，怎么应用这些经典算法的思想，这也是需要培养的。

## 二分

### CSP 202303-1二分搜索

这里check函数没有写好的，导致结果一直不多对，如果结果不对的话需要检查check函数的编写逻辑是否正确。

### [COCI2011-2012#5] EKO / 砍树（二分答案） | [P1873](https://www.luogu.com.cn/problem/P1873)

使用二分答案解题：使用二分搜索时要看是，满足条件的解**尽量往右找还是尽量往左找**，对应使用不同的模版。

### [NOIP2001 提高组] 一元三次方程求解 | [P1024](https://www.luogu.com.cn/problem/P1024)

二分搜索的时候，一定要确定好判断条件和区间，然后再是，如果卡住就重新审题，这题是因为没有审清题目，变量是double而不是int

### 烦恼的高考志愿 | [P1678](https://www.luogu.com.cn/problem/P1678)

二分搜索：确定尽量往左求还是右求，但是求出来的一定**是大于等于，不可能是小于**，最后要注意判断条件

```c++
    for (int i = 0; i < n; i++)
    {
        int temp = binSearch(s[i]);

        int split1 = abs(s[i] - t[temp]);

        int split2 = abs(temp - 1 >= 0 ? s[i] - t[temp - 1] : 1 << 30);//这里temp的范围出错了写成了temp>0找了好久好久。
        sum += min(split1, split2);
    }
```

### [NOIP2015 提高组] 跳石头 | [P2678](https://www.luogu.com.cn/problem/P2678)

使用二分答案求解，第一次过10% ，模拟**消除岩石的时候出错**，消除岩石后应该是也可能影响后边导致后边的变化，然后就是二分的判断条件出错导致不是**尽量向左寻找**。这里数据结构使用了链表，一开始使用数据值错误的。最后20%是边界问题，L,M,N的范围中都有可能是零，这种极端情况没有考虑到。

### 数列分段 Section II | [P1182](https://www.luogu.com.cn/problem/P1182)

使用二分搜索+贪心算法求出来，重点是贪心算法想不到，求一个数组的连续最大和的最小值，可以从一开始然后遍历到最后，如果大于的那个最小值，则新开一个子数组，然后就可以看到需要分多少个子数组了。

没想到贪心的原因：不知道从何入手，不知道该怎么遍历所有解，**还有就是没有确定好check函数的功能**，是检测一个解可不可行，而不是用贪心一下求出来，而是用贪心的策略，检测可不可行，需要用划分多少个子数组，**想要用最少个子数组来达到目的，不就是贪心吗？**

### [USACO07MAR] Face The Right Way G | [P2882](https://www.luogu.com.cn/problem/P2882)

这题主要卡住的地方是**贪心**和**前缀和**的应用（本来这题就考这两点结果一个也没想起来）

贪心的应用就是碰见一个**不为朝前的牛就让他后边的K个全部反转**，最终这样会求出来当前K值下最小的操作数（不知道为啥没想到，可能是没有从一般的人工的方法中抽象出来一般的方法策略）

然后前缀和就是用一个前缀和数组来记录第i个奶牛的反转次数，这个我是想到了的，但是我没想到，用一个变量来存当前前缀和的和，也就是当前第i个奶牛的反转次数，光想着要求当前奶牛的反转次数就要重新从头开始累加求前缀和（根本没有意识到，这些求和是重复的工作），前缀和的算法的**最核心的思想就是保存之前的值，然后减少重复求和，**没有把握好核心思想光生搬硬套了。

### [Poetize6] IncDec Sequence | [P4552](https://www.luogu.com.cn/problem/P4552)

这题虽然知道要用前缀和和差分来优化，但是没想到要**完全用差分来解题**，虽然题目中涉及到了区间操作，我只想着把差分来转换区间操作，但是这样是不完全的，因为差分就是每个元素之间的差，我们可以让这个差为零**也就是差分数组的每一项都为零**，就可以达到题目条件

其次就是种类数，因为种类数是和差分数组的第一个元素的值有关，如果我们把单个**的减少或增加与第一个元素联系起来然**后我们就可以实现了对第一个 元素的改变，最终实现的求出种类数。

这题关键不能陷入了平常让所有数相同的一般思维，要用**差分的思想**，将题目转换为了一般的容易思考的，所以首先要转换问题，然后再求解。

### [USACO11NOV] Cow Lineup S | [P3029](https://www.luogu.com.cn/problem/P3029)

**离散化+双指针+map+set:**

首先离散化很容易就想到了，但是**双指针（普通指针也就两个指针往同一方向前进）**不好想，因为**要是使用到map数据结构来保存照片中的各个种类的个数，**首先要从开头开始想，r=2,l=1时用什么策略去移动指针，然后在想到策略是如果可以减少重复的种类的个数，就可以让左边的指针前移，然后右边的指针要遍历的前移，左边的是看情况前移。

重温map的使用方法。

### [CEOI1999] Parity Game | [P5937](https://www.luogu.com.cn/problem/P5937) 前缀和+离散化+并查集

这题首先卡住我是如何是使用并查集，离散化不难想到，重点是**前缀和和并查集**。

首先**一看到是片段操作，就应该想到前缀和和差分**，因为这两个操作是与区间操作十分相关的技术，然后我们就可以发现一个规律：**就是一个区间含1的个数只与开始和结尾的元素有关**，我们只用判断开始和结尾的元素的奇偶性想不相同就可以判断区间的奇偶性。

然后我们在想到并查集，而且是**扩区域的并查集**，什么意思呢？就是在并查集的基础上多加几个集合，就是一个元素有多个集合要存，就像这题既要**保存奇偶性相同的，也要保存与他奇偶性不相同的**。也就是两个完全不同并查集的树，来保存这两个集合。

## 动态规划



### [NOIP1996 提高组] 挖地雷 | [P2196](https://www.luogu.com.cn/problem/P2196) 动态规划

这题一开始知道是动态规划但是没有想到**如何将问题分解为小问题**，也就是不知道如何求出**递推表达式**，可能还是没有掌握动态规划的精髓。

这题应该将$dp_i$设置为**以i为终点的路径的总权**，然后第二层**for是寻找这个终点的前一个点（要保证这个点最大**），然后第一层for是寻找出，**所有点为终点的结果，**然后就是使用数组来保存路径

然后中间出了一个小bug（也找了很久）

**因为找最大值时设置的初值不对然后就导致极端情况下用的初值**，然后导致情况出错以后要注意

### [SHOI2002] 滑雪 | [P1434](https://www.luogu.com.cn/problem/P1434) 动态规划/无后效性

#### 无后效性

**已经求解的子问题，不会再受到后续决策的影响。**

这题的动态规划很容易想到但是问题是**如何解决无后效性**成为了问题的关键。

动态规划的递推公式是

$$\huge dp_{ij}=max(dp_{i-1,j},dp_{i,j-1},dp_{i+1,j},dp_{i,j+1})+1$$

然后就是以什么样的顺序来求解$dp_{ij}$， 然后考虑到动态规划要求的无后效性，我们是使用先讲高度地点地方的$dp_{ij}$算出来，逐渐到最大的height的$dp_{ij}$，最终求得最优解问题。

### 最大食物链计数 | [P4017](https://www.luogu.com.cn/problem/P4017) 动态规划+拓扑排序+队列

这题动态规划容易想到，但是由于**动态规划要求无后效性**，所以我们求解的顺序就要以一个特定的顺序，不像前一问可以直接用排序解决无后效性这个问题，因为是图论的问题，我们要使用到**拓扑排序**，来确定出子问题的求解顺序（不看题解谁想的出来的啊）

这题的卡点，首先是读题 

1. 求的是最大食物链的数量而不是长度
2. 因为数很大所以要**一开始就要求模在过程中就要求模**,不然回导致过大而超出空间。
3. 还有就是要使用**队列**这个数据结构,使用stl，然后就挺方便的。
4. 还有要注意分清吃与被吃的关系，有向图的边要搞清楚，入度和出度分别代表什么含义要搞清楚。
5. 还有就是dp的初始化，**题目没有说生产者和最优捕食者只有一个，**所以我们要对所有的入度为零的dp初始化，（这个最后卡了我很久，以后要加强读题）

### 最大子段和 | [P1115](https://www.luogu.com.cn/problem/P1115)　动态规划＋滚动数组

这题也是经典的动态规划，不过和前面两个题的动态规划还不太一样，因为前面两个动态规划是**以解决题目的问题为最大解的**，也就是说上面两题最终求出来的dp直接就是问题的解，因为分解的过程是把求解的规模逐渐变大然后**把最终的问题的解寄托于最后求得的那个dp**，然而这个问题并不是这样。这个问题是求出诸多个解（也就是多个连续子序列片段和）然后通过比较求出最大值。

$\huge dp_i$的含义是以第i个数结尾的最大连续子序列的和的最大值

递推公式 ：$\huge dp_i=max(dp_{i-1}+a_i,a_i)$

而不是我想的$\huge dp_i$是第0个数到第i个数的最大连续子序列的和，这样虽然是直接对问题规模的小化和求解，但是这样求解不出来，因为没办法递归求下去，前一个问题的解和后一个问题解不相关。不符合**子问题重叠**和**最优子结构**的动态规划特性

### 疯狂的采药 | [P1616](https://www.luogu.com.cn/problem/P1616) 动态规划：完全背包问题模板

这题是经典的完全背包问题

重点理解完全背包问题的递推公式：
$$
f_{ij}=max(f_{i-1,j},f_{i,j-w_i}+v_i)
$$
求解物品选多少个时：不是从$f_{i-1}$状态推出，因为有重复的计算，要从$f_{i}$第i物品j-1个 导出。

**dp数组记得用long**

### 小A点菜 | [P1164](https://www.luogu.com.cn/problem/P1164)动态规划+边界初始值设置

第一次提交：看错题你以为是最大的订菜数量，**应该是订菜的策略的数量**

第二次提交：状态转移方程错误

错误：
$$
f_{ij}=max(f_{i-1,j-a[i]}+1,f_{i-1,j})
$$
第三次提交：

以为策略是两者的最大值，**实际上没有搞清楚的$f_{ij}$的含义**

错误：
$$
f_{i,j}=max(f_{i,j-a[i]},f_{i-1,j})
$$
第四次提交看题解：
$$
f_{ij}=f_{i-1,j-a[i]}+f_{i-1,j}
$$
初始情况设置：

```c++
    for (int j = 1; j <= M; j++)
    {
        for (int i = 1; i <= N; i++)
        {
            if (a[i]==j)
            {
                dp[j][i]=dp[j][i-1]+1;
            }
            else if (j > a[i])
                dp[j][i] = dp[j-a[i]][i - 1]+dp[j][i-1];
            else
                dp[j][i] = dp[j][i - 1]; 
        }
    }
```

### [NOIP2012 普及组] 摆花 | [P1077](https://www.luogu.com.cn/problem/P1077)动态规划

多重背包问题

$dp_{ij}$表示有i种花，容量为j下的策略的数量

**最重要的是初始值的设置**

**$dp_{00}=1$**

状态转移方程：
$$
dp_{ij}+=dp_{i-1,j-k}
$$
k是第i种花选取的数量

最终可以得到n种花容量为m的最大策略数量

### kkksc03考前临时抱佛脚 | [P2392](https://www.luogu.com.cn/problem/P2392) 动态规划+应用实际+倒序

首先能否想到这是一个背包问题就是一个难点，因为是左右脑并行的，然后所有的题目又是一定要完成的，所以有一个限制条件，左右脑完成的题目的时间的和是一定的，所以确定一个脑完成的内容另一个脑袋要完成的内容也就确认了，所以可以简化为背包问题。

**其次就是如果最大的时间也确定了是$\frac{t}{2}$也就是容量，让最后的dp无线接近时间最短然后就好了。**

然后还有一个bug就是，**如果用一维dp数组优化空间的话，我们就需要从后往前遍历**，因为这样保证dp计算用的是前一个状态的dp而不是这一个状态的dp。

### [NOIP2006 提高组] 金明的预算方案 | [P1064](https://www.luogu.com.cn/problem/P1064)

动态规划，这题是比较复杂的递推公式。

这题是通过简化题目，**因为一个主件最多只有三个附件，所以我们可以遍历每一种情况，**然后再使用dp，转换成了经典的背包问题。

**用一维dp优化空间时要从后往前推进，这样保证用的是上一个状态的dp**

其次就是**如果用一维dp数组优化空间的话，我们就需要从后往前遍历**，因为这样保证dp计算用的是前一个状态的dp而不是这一个状态的dp，**如果是同一层的dp的话，那样的就会导致同一个物品多次选的结果**。



我们可以发现一般的dp出题不会直接给一个符合经典dp问题的，都会要是简化一下，然后再迁移一下才能用dp做，就像P1064需要一个遍历，P2392需要将一个两个脑袋转换为一个脑袋的问题。

### [TJOI2007] 线段 | [P3842](https://www.luogu.com.cn/problem/P3842)

这题也是一个看似可以贪心的问题但是实践上一个子问题的最优解并不是全局的最优解，所以还得是动态规划。但是**怎么用动态规划也是要转一个弯**。

如果直接用动态规划的话时间复杂度是$O(n^2)$这样会直接超时

这时我们可以想着简化一下dp，因为下一行的dp仅仅用的到**上一行线段两边端点的dp**所以我们就简化了dp的维数并且简化了dp的时间复杂度。



## 贪心

我认为贪心最主要的就是寻找一个最优的策略，然后使用这个策略求解出一个最优解

### 凌乱的yyy / 线段覆盖 | [P1803](https://www.luogu.com.cn/problem/P1803)

这题一看复杂度，必然使用贪心算法而不是动态规划，那么其次就是要求贪心的策略。

下面来写下我对策略的思考过程：

1. 只要保证在当前时间点，选择最短持续时间的比赛，并且保证时间不冲突，简单来说就是优先选相同开始时间下优先选择持续时间最短的比赛。

   发现这个并不能保证最优，因为使用了这个策略，就使得先开始比赛一定会比后开始的比赛优先选，然后就使得结果不是最优了，比如后开始的持续时间更短，但是上边那个策略选不到他

2. 针对上面那个错误，我想到既然不能用开始时间来选择，那么是不是可以选择时间最短的，然后保证不冲突。

   但是我们细想一下我们怎么确保选择时间最短并且保证不冲突啊？肯定不能直接对持续时间进行排序然后选择，这样没有办法确保他们不冲突啊，要想确保他们不冲突就要对他们进行时间顺序的排序，然后上一个结束时间比下一个开始时间要小就能保证不冲突，但是这样没有办法同时兼顾优先时间短的选择。

3. 那么只要保证持续时间短和最先开始的就可以，而直接实现这两条并不简单因为这是两个排序标准很难结合在一起：如果先对持续时间进行排序再对开始时间排序，那么就导致的是相同开始时间的持续时间有顺序，没有实现这个；如果先对开始时间进行排序再对持续时间进行排序，那么就是相同持续时间的开始时间有顺序，也没办法保证有时间顺序的。

4. 所以我们最后可以看我们想要有时间顺序的并且短时间优先的，那么需要找一个排序对象来实现的，具体就是的对结束时间进行排序，那么既保证了有时间顺序的，又保证了短时间的优先。

### [NOIP2018 提高组] 铺设道路 | [P5019](https://www.luogu.com.cn/problem/P5019)

这题的贪心思路并不难，就是一直让区间最大化就好了，这样每一部分的时间最短总体时间就是最短。

其次就是关键是通过区间来分治的，用最小值来划分区间，最小值左边和最小值右边两个区间。

还有一种方法就是，递推，从左边开始，逐渐加一往右走，不过要有地推表达式。

### [AHOI2018初中组] 分组 | [P4447](https://www.luogu.com.cn/problem/P4447)

这题是贪心的有一个中等的题目，难点同样不是贪心的策略，重点是将贪心策略通过数据结构实现出来。

贪心策略就是每次将最小的分组变成长一点的分组。

对于每个分组我们其实只用存它的长度和需要的下一个实力值就行。

然后使用二分查找查找出来对应位分组然后更新就好了。

> 感悟：
>
> 我们使用算法一般都是需要自己创造条件，比如这题我们需要给数组排序才能使用二分搜索
>
> 还有就是抽象能力，将实际问题转换为数据结构等等

## 二维前缀和数组

**b [i] [j]表示在i行j列的这个数组的和，**可以通过加减来表示子矩阵的和，然后我们就可以根据这个意义来推导出b [i] [j] 的公式

*b[i] [j]= b[i - 1] [j] + b[i] [j - 1] - b[i - 1] [j - 1] + a[i] [j];*

## 二维差分数组

### 推导公式

  二维差分我们通常称之为差分矩阵。通过结合一维差分我们可以想到，它的作用是可以让某个子矩阵在`O(1)`的时间复杂度内让所有元素都加上`c`。

  而我之前一直都在强调一点——**前缀和与差分是逆运用，二维亦是如此**。

​		**求一个数组的差分，就和将前缀和数组还原成原数组的操作一样**。所以可以了解将前缀和数组还原成原数组的操作，也就是可以推出求原数组的差分数组的过程。二维数组也是如此，所以我们可以通过这种方式来推导出来公式。

先根据二维前缀和数组的公式***b[i] [j]= b[i - 1] [j] + b[i] [j - 1] - b[i - 1] [j - 1] + a[i] [j]***

来推导出a[i] [j]=b[i] [j]-b[i - 1] [j] - b[i] [j - 1] + b[i - 1] [j - 1]  (**a是b的差分数组，b是a的前缀和数组**) , 于是我们就得到了求差分数组的公式: a是原数组 b是a的差分数组

**b[i] [j]=a[i] [j]-a[i - 1] [j] - a[i] [j - 1] + a[i - 1] [j - 1]**

我们也可以分析一下这个式子的意义：b[i] [j] 就是原本a[i] [j]与周围元素的差，然而这个差与一维数组的不尽相同。

```c++
    for (int i = 0; i < m; i++)
    {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        rug[x1][y1]++;
        rug[x2 + 1][y1]--;//注意要加的位置
        rug[x1][y2 + 1]--;//容易出错导致结果不对
        rug[x2 + 1][y2 + 1]++;
    }//执行制定区间的加减操作
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            rug2[i][j] = rug2[i - 1][j] + rug2[i][j - 1] - rug2[i - 1][j - 1] + rug[i][j];//使用前缀和数组还原
            cout << rug2[i][j] << ' ';
        }
        cout << endl;
    }
```

## 二分答案（二分搜索的一种）

题目的可行解在一个范围区间内，这个区间太大导致直接遍历会超时，然后就需要用**二分搜索**，适用情况：

> ###### 1、答案在一个区间内（一般情况下，区间会很大，暴力超时）
>
> ###### 2、直接搜索不好搜，但是容易判断一个答案可行不可行
>
> ###### 3、该区间对题目具有单调性，即：在区间中的值越大或越小，题目中的某个量对应增加或减少。

此外，可能还会有一个典型的特征：求...最大值的最小 、 求...最小值的最大。
1、求...最大值的最小，我们二分答案（即二分最大值）的时候，判断条件满足后，尽量让答案往前来（即：让r=mid），**对应模板1；**
2、同样，求...最小值的最大时，我们二分答案（即二分最小值）的时候，判断条件满足后，尽量让答案往后走（即：让l=mid）**，对应模板2；**

模板1：尽量往左找目标

```c++
	while (l < r)
    {
        int mid = l + r >> 1;	//(l+r)/2
        if (check(mid))  r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
```

模板2：尽量往右找目标。

```c++
	while (l < r)
    {
        int mid = l + r + 1 >> 1;	//(l+r+1)/2
        if (check(mid))  l = mid;
        else r = mid - 1;
    }
```

**只要是往左找答案，就用第一个模板，mid不用加一，r=mid，l加一；
只要是往右找答案，就用第二个模板，mid要加一，l=mid，r要减一；**





## 动态规划



### 基本思想



现在把动态规划方法的基本思想归纳如下。 

(1 ) 动态规划方法的关键在于正确地写出基本的递推关系式和恰当的边界条件( 简言之为基本方程)。要做到这一点, 必须先将问题的过程分成几个相互联系的阶段, 恰当地选取状态变量和决策变量及定义最优值函数, 从而把一个大问题化成一族同类型的子问题,然后逐个求解。即从边界条件开始, 逐段递推寻优,在每一个子问题的求解中, 均利用了它前面的子问题的最优化结果,依次进行, 最后一个子问题所得的最优解,就是整个问题的最优解。

(2 ) 在多阶段决策过程中, 动态规划方法是既把当前一段和未来各段分开, 又把当前效益和未来效益结合起来考虑的一种最优化方法。因此, 每段决策的选取是从全局来考虑的,与该段的最优选择答案一般是不同的。 

(3 ) 在求整个问题的最优策略时, 由于初始状态是已知的,而每段的决策都是该段状态的函数,故最优策略所经过的各段状态便可逐次变换得到, 从而确定了最优路线。 

###　建立模型

在明确了动态规划的基本概念和基本思想之后,我们看到, 给一个实际问题建立动态 

规划模型时,必须做到下面五点: 

(1 ) 将问题的过程划分成恰当的阶段; 

(2 ) 正确选择状态变量 $s_k$ , 使它既能描述过程的演变,又要满足无后效性; 

(3 ) 确定决策变量 $u_k$ 及每阶段的允许决策集合 $D_k(S_k)$; 

(4 ) 正确写出状态转移方程; 

(5 ) 正确写出指标函数 $V_{k,n}$, *n*的关系,它应满足下面三个性质: 

① 是定义在全过程和所有后部子过程上的数量函数; 

② 要具有可分离性,并满足递推关系。即 

$\huge V_{k, n}( s_k ,k_k , …, s_{n+1}) =ψ […, *s**n* + 1 ) ] $

③ 函数 ψ

*k* ( *s**k* , *u**k* , *V**k* + 1 , *n* ) 对于变量 *V**k* + 1 , *n*要严格单调

###  与静态规划的区别

动态规划、线性规划和非线性规划都是属于数学规划的范围, 所研究的对象**本质上都是一个求极值的问题,**都是利用**迭代法去逐步求解的**。不过, **线性规划和非线性规划所研究的问题,通常是与时间无关的**, 故又称它们为静态规划。**线性规划迭代中的每一步是就问题的整体加以改善的**。

而动态规划所研究的问题是与时间有关的, 它是研究具有**多阶段决策过程的一类问题,将问题的整体按时间或空间的特征而分成若干个前后衔接的时空阶段,把多阶段决策问题表示为前后有关联的一系列单阶段决策问题, 然后逐个加以解决,从而求出了整个问题的最优决策序列。**因此, 对于某些静态的问题, 也可以人为地引入时间因素,把它看作是按阶段进行的一个动态规划问题, 这就使得动态规划成为求解某 些线性、非线性规划的有效方法。

### 逆推解法

设已知初始状态为 *s*1 ,并假定最优值函数 $f_k(s_k)$表示第 *k* 阶段的初始状态为 *s**k* , 从 *k*阶段到 *n* 阶段所得到的最大效益。 

### 0-1背包问题

例题中已知条件有第 $i$ 个物品的重量 $w_{i}$，价值 $v_{i}$，以及背包的总容量 $W$。

设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。

考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$；当其放入背包时，背包的剩余容量会减小 $w_{i}$，背包中物品的总价值会增大 $v_{i}$，故这种情况的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$。

由此可以得出状态转移方程：

$$
f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})
$$

这里如果直接采用二维数组对状态进行记录，会出现 MLE。可以考虑改用滚动数组的形式来优化。

由于对 $f_i$ 有影响的只有 $f_{i-1}$，可以去掉第一维，直接用 $f_{i}$ 来表示处理到当前物品时背包容量为 $i$ 的最大价值，得出以下方程：

$$
f_j=\max \left(f_j,f_{j-w_i}+v_i\right)
$$

**务必牢记并理解这个转移方程，因为大部分背包问题的转移方程都是在此基础上推导出来的。**



### 完全背包问题

完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。

我们可以借鉴 0-1 背包的思路，进行状态定义：设 $f_{i,j}$ 为只能选前 $i$ 个物品时，容量为 $j$ 的背包可以达到的最大价值。

需要注意的是，虽然定义与 0-1 背包类似，但是其状态转移方程与 0-1 背包并不相同。

### 过程

可以考虑一个朴素的做法：对于第 $i$ 件物品，枚举其选了多少个来转移。这样做的时间复杂度是 $O(n^3)$ 的。

状态转移方程如下：

$$
f_{i,j}=\max_{k=0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)
$$

考虑做一个简单的优化。可以发现，对于 $f_{i,j}$，只要通过 $f_{i,j-w_i}$ 转移就可以了。因此状态转移方程为：

$$
f_{i,j}=\max(f_{i-1,j},f_{i,j-w_i}+v_i)
$$

理由是当我们**这样转移时，$f_{i,j-w_i}$ 已经由 $f_{i,j-2\times w_i}$ 更新过，那么 $f_{i,j-w_i}$ 就是充分考虑了第 $i$ 件物品所选次数后得到的最优结果。**换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。

与 0-1 背包相同，我们可以将第一维去掉来优化空间复杂度。如果理解了 0-1 背包的优化方式，就不难明白压缩后的循环是正向的（也就是上文中提到的错误优化）。

### 多重背包问题

多重背包问题就是要实现对背包的数量状态的遍历，和完全背包问题的区别是物品数量不是无限的，是有限的而且每个物品可能还不一样，这时候就不能再用完全背包的状态转移方程了。
$$
f_{ij}=max(f_{i-1,j},f_{i-1,j-k*w[i]}+v_i)
$$
所以基本就是要用三层for来实现

### 状态压缩DP

状态压缩DP的思想就是将一个状态用一个二进制串表示，然后再用这个二进制串来进行状态转换。

与经典的动态规划的区别就是用二进制串来表示状态的。

## sort函数

一、sort函数调用的两种方式
方式一(默认)	

```c++
void sort (RandomAccessIterator first, RandomAccessIterator last);
```

方式二(自定义):	

```c++
void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
```

默认: 两个参数first,last，将 **[first, last)**区间内元素升序排列。**【注意区间为左闭右开】**

自定义排序: 需用户指定排序规则Compare comp,将 **[first, last)**区间内的元素按照用户指定的顺序排列。

## 优先队列

听这个名字就能知道，优先队列也是一种队列，只不过不同的是，**优先队列的出队顺序是按照优先级来的；**在有些情况下，可能需要找到元素集合中的最小或者最大元素，可以利用优先队列ADT来完成操作，优先队列ADT是一种数据结构，它支持插入和删除最小值操作（返回并删除最小元素）或删除最大值操作（返回并删除最大元素）；

这些操作等价于队列的`enQueue`和`deQueue`操作，区别在于，对于优先队列，元素进入队列的顺序可能与其被操作的顺序不同，作业调度是优先队列的一个应用实例，它根据优先级的高低而不是先到先服务的方式来进行调度；

如果最小键值元素拥有最高的优先级，那么这种优先队列叫作**升序优先队列**（即总是先删除最小的元素），类似的，如果最大键值元素拥有最高的优先级，那么这种优先队列叫作**降序优先队列**（即总是先删除最大的元素）；由于这两种类型时对称的，所以只需要关注其中一种，如升序优先队列；

### 使用代码介绍

priority_queue<T>：是一个封装了 vector<T> 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。priority_queue<T> 模板定义在头文件 queue 中。

## string （字符串）

replace函数

```c++ string类的replace
1.1 string：string& replace (size_t pos, size_t len, const string& str);
原型：string& replace (size_t pos, size_t len, const string& str);
说明：删除源字符串从下标为pos处开始的len个字符，然后在pos处插入string型字符串str。
代码示例：
```

erase函数

> `erase` 是 C++ 标准库中 `std::string` 类的一个成员函数。它用于从字符串中删除一个或多个字符。
>
> 在你的代码 `n.erase(i,1);` 中，`erase` 函数有两个参数：
>
> - `i` 是一个整数，表示要删除的第一个字符的位置。位置从 0 开始计数，所以 `i` 是在字符串 `n` 中的索引。
> - `1` 是一个整数，表示要删除的字符的数量。在这个例子中，从位置 `i` 开始，只删除一个字符。
>
> 所以，`n.erase(i,1);` 的作用是删除字符串 `n` 中位置 `i` 的字符。

例如，如果 `n` 是字符串 `"Hello"`，`i` 是 `1`，那么 `n.erase(i,1);` 之后，`n` 将变为 `"Hllo"`。

**如果循环遍历使用erase函数的时候，注意下标的变化，比如我们使用循环遍历时使用了erase函数，此时下标不加一否则就会跳过一个没有遍历到**

## list(链表)

### list的介绍

1. list是序列容器，允许在序列中的任何位置执行固定O(1)时间复杂度的插入和删除操作，并在两个方向进行迭代。

2. list容器使用双链表实现；双链表将每个元素存储在不同的位置，每个节点通过next，prev指针链接成顺序表。

3. list与其他标准序列容器（array，vector和deque）相比，list通常可以在容器内的任何位置插入、提取和移动元素。

4. list与其他标准序列容器（array，vector和deque）相比，list和forward_list（单链表实现）的主要缺点是他们不能通过位置直接访问元素；例如，要访问列表中的第五个元素，必须从已知位置（开始或结束）迭代到该位置，需要哦线性时间开销。

5. 存储密度低，list要使用一些额外的内容空间（next，prev）来保持与每个元素相关联（前后续的线性）的链接信息，从而导致存储小元素类型（如char，short，int等）的列表的存储密度低。

   

### list的插入



| 修改器                                                       | 功能                                            |
| ------------------------------------------------------------ | :---------------------------------------------- |
| void clear();                                                | 从容器擦除所有元素。此调用后 size() 返回零。    |
| iterator insert( iterator pos, const T& value )              | 在 pos 前插入 value 。                          |
| void insert( iterator pos, size_type count, const T& value ); | 在 pos 前插入 value 的 count 个副本。           |
| void **insert**( iterator pos, InputIt first, InputIt last); | 在 pos 前插入来自范围 [first, last) 的元素      |
| iterator **insert**( const_iterator pos, std::initializer_list ilist ); | 在 pos 前插入来自 initializer_list ilist 的元素 |
| iterator **erase**( iterator pos );                          | 移除位于 pos 的元素。                           |
| iterator **erase**( iterator first, iterator last );         | 移除范围 [first; last) 中的元素。               |
| void **pop_back**();                                         | 移除容器的末元素。                              |
| void **push_front**( const T& value );                       | 前附给定元素 value 到容器起始。                 |
|                                                              |                                                 |
|                                                              |                                                 |
|                                                              |                                                 |
|                                                              |                                                 |
|                                                              |                                                 |
|                                                              |                                                 |
|                                                              |                                                 |

## set（集合）

### 1. 介绍

set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。

即：set里面的元素不重复 且有序

```c++
//头文件
#include<set>
//初始化定义
set<int>se;
int a[]={1,2,3,4,5};
set<int>se(a,a+5);
```

1. 函数方法

  | 代码                  | 含义                                                                |
  | --------------------- | ------------------------------------------------------------------- |
  | s.begin()             | 返回set容器的第一个元素的地址（迭代器）                             |
  | s.end()               | 返回set容器的最后一个元素的下一个地址（迭代器）                     |
  | s.rbegin()            | 返回逆序迭代器，指向容器元素最后一个位置                            |
  | s.rend()              | 返回逆序迭代器，指向容器第一个元素前面的位置                        |
  | s.clear()             | 删除set容器中的所有的元素,返回unsigned int类型O(N)                  |
  | s.empty()             | 判断set容器是否为空                                                 |
  | s.insert()            | 插入一个元素                                                        |
  | erase(iterator)       | 删除定位器iterator指向的值                                          |
  | erase（first,second） | 删除定位器first和second之间的值                                     |
  | erase(key_value)      | 删除键值key_value的值                                               |
  | s.find(元素)          | 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 |
  | s.lower_bound(k)      | 返回大于等于k的第一个元素的迭代器                                   |
  | s.upper_bound(k)      | 返回大于k的第一个元素的迭代器                                       |

**查找**

   | 代码             | 含义                                                                |
   | ---------------- | ------------------------------------------------------------------- |
   | s.find(元素)     | 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 |
   | s.lower_bound(k) | 返回大于等于k的第一个元素的迭代器                                   |
   | s.upper_bound(k) | 返回大于k的第一个元素的迭代器                                       |

1. 访问
    a.迭代器访问

```c++
for(set<int>::iterator it=s.begin();it!=s.end();it++)
 cout<<*it<<" ";

b.简便的方法

for(auto i : s)
 cout<<i<<endl;

c.访问最后一个元素

//第一种
cout<<*s.rbegin()<<endl;

 //第二种
set<int>::iterator iter = s.end();
iter--;
cout<<(*iter)<<endl; //打印2;

//第三种
cout<<*(--s.end())<<endl;

1. 重载<运算符
//重载<运算符
struct cmp {
    bool operator () (const int& u, const int& v) const
    {
       // return + 返回条件
    }
};
set<int, cmp> se;
```

其它的set
multiset:元素可以重复，且元素有序
unordered_set ：元素无序且只能出现一次
unordered_multiset ： 元素无序可以出现多次

## map(映射)

**map不可以<int,char[]>必须<int,string>，map的键值唯一**

### map容器内元素的访问

map 一般有两种访问方式∶通过下标访问或通过迭代器访问。下面分别讨论这两种访问方式。

**（1）通过下标访问**

和访问普通的数组是一样的，例如对一个定义为 map<char，int> mp 的map 来说，就可以直接使用 mp[‘c’]的方式来访问它对应的整数。于是，当建立映射时，就可以直接使用mp[‘c’]=20 这样和普通数组一样的方式。但是要注意的是，map中的键是唯一的，也就是说，下面的代码将输出30∶

```c++
#include<iostream>
#include<map>
using namespace std;
//map
int main()
{
	map<char,int> mp;
	mp['c'] = 20;
	mp['c'] = 30; // 20被覆盖	

	cout << mp['c'] << endl;
	
	return 0;
}
```


输出结果：

30
**（2）通过迭代器访问**

map 迭代器的定义和其他 STL 容器迭代器定义的方式相同∶

```c++
map<typenamel,typename2>::iterator it;
```


typename1和typename2就是定义 map 时填写的类型，这样就得到了迭代器it。map 迭代器的使用方式和其他 STL 容器的迭代器不同，因为 map 的每一对映射都有两个typename，这决定了必须能通过一个 it 来同时访问键和值。事实上，map可以使用 it->first 来访问键，使用 it->second 来访问值。

```c++
#include<iostream>
#include<map>

using namespace std;

//通过迭代器访问
//it -> first访问键
//it -> second访问值 
int main()
{
	map<char,int> mp;
	

	mp['m'] = 20;
	mp['r'] = 30;
	mp['a'] = 40;
	
	//it -> first 是当前映射的键
	//it -> second是当前映射的值 
	for(map<char,int>::iterator it = mp.begin(); it != mp.end(); it++)
	{
		cout << it -> first << " " << it -> second << endl;
	}
	
	return 0;

}


```

输出结果：

```php
a 40
m 20
r 30

```


接下来似乎发现了一个很有意思的现象：map会以键从小到大的顺序自动排序，即按 a<m<r的顺序排列这三对映射。这是由于map 内部是使用红黑树实现的（set也是），在建立映射的过程中会自动实现从小到大的排序功能。

### map.find()

map.find(key)返回的是iterator，iterator->first 是键值 ，iterator->second 是值

判断是否找到可以用

```c++
map<int,int> m;
m[1]=1;
map<int,int>iterator it=m.find(1);
if(it==m.end()){
    //没有找到
    cout<<"no find"
}else if(it!=m.end()){
    cout<<"键值是："<<it.first<<endl<<"值是："<<it.second;
}
```

### map.earse()

可以直接

```c++
map.earse(key)
```

删除key与对应的值

## ST表

st表是一种基于连续存储的（也就是数组的）数据结构

st表是用来解决重复贡献问题的一种办法

> 重复贡献问题在我理解下就是
>
> 定义域有重复的区域，但是求出的结果还是一样的问题就是可重复贡献问题。

知道了重复贡献问题

我们就会发现求区间最大值就是可重复贡献问题

> 求一整个区间我们可以用两段有重复的区间，来求一整段区间的最大值
>
> 示意图
>
> ![1706670791563-screenshot](D:\c++\luogu\总结.assets\1706670791563-screenshot.png)

然后st表（Sparse Table）就应运而生，

> 是一种用于解决区间最值查询问题的数据结构。它的主要思想是预处理所有可能的区间，然后在查询时直接返回预处理的结果。

设二维数组f[i][j]代表从i号位置开始(包括i号元素)往后推$2^j$个单位长度的区间里的最大值，即￥$[i,i+2^j-1]$区间的最大值

然后更新的状态方程就是这样

$f(i,j)=max(f(i,j-1),f(i+2^{j-1},j-1))$

原因是什么的且看示意图

![1706672116572-screenshot](D:\c++\luogu\总结.assets\1706672116572-screenshot.png)



然后我们也就是得到了每个元素作为开头，然后长度为1，2，4，到$2^k$的区间的最大值

分别存在$f[i][0]、f[i][1] 、f[i][2]、……f[i][k]$ 中

然后我们查询的时候只要先找到一个k大于等于区间长度二分之一，然后我们就可以分解为两个f的值的最大值，那么那两个f是什么呢？

![1706672695579-screenshot](D:\c++\luogu\总结.assets\1706672695579-screenshot.png)

所以我们可以确定为

$\huge max(f[l][k],f[r-2^k+1][k])$

然后我们就求出来l，r区间上的最大值了

给出一个实例代码

**【模板】ST 表 | [P3865](https://www.luogu.com.cn/problem/P3865)**

```c++
#include <iostream>  // 引入iostream库，用于输入输出
using namespace std;  // 使用std命名空间
int N, M;  // 定义两个全局变量N和M
int lg[100001];  // 定义一个数组lg，用于存储预处理的对数值
long f[100001][20];  // 定义一个二维数组f，作为ST表

int main()  // 主函数
{
    int i = 0, j;  // 定义两个局部变量i和j，用于循环
    int l = 1, r = 1, a, s;  // 定义四个局部变量l，r，a和s
    scanf("%d%d", &N, &M);  // 从标准输入读取两个整数到N和M

    lg[0] = -1;  // 初始化lg数组的第0个元素为-1
    for (i = 1; i <= N; i++)  // 对于1到N的每个i
    {
        scanf("%d", &a);  // 从标准输入读取一个整数到a
        lg[i] = lg[i >> 1] + 1;  // 计算lg[i]
        f[i][0] = a;  // 将a的值存入ST表
    }

    for (j = 1; j <= lg[N]; j++)  // 对于1到lg[N]的每个j
    {
        for (i = 1; i <= N - (1 << j) + 1; i++)  // 对于1到N-(2^j)+1的每个i
        {
            f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);  // 计算ST表的值
        }
    }
    for (i = 0; i < M; i++)  // 对于0到M-1的每个i
    {
        scanf("%d%d", &l, &r);  // 从标准输入读取两个整数到l和r
        s = lg[r - l + 1];  // 计算s的值
        printf("%d\n", max(f[l][s], f[r - (1 << s) + 1][s]));  // 输出查询结果
    }
    return 0;  // 主函数返回0，表示程序正常结束
}
```



## upper_bound和lower_bound 二分查找

lower_bound 返回的是第一个 大于等于 val 的位置,upper_bound 返回的是第一个大于val的位置

   lower_bound(first, end, val)

   upper_bound(first, end, val)

> 例如: 有序数组  1, 5, 9, 11, 11, 13
>
>  lower_bound(first, end, 5) - first  =  1
>
>  upper_bound(first, end, 5) - frist =  2
>
>  lower_bound(first, end, 6) - first = 2
>
>  upper_bound(first, end, 6) - first = 2
>
>  lower_bound(first, end, 11) - first = 3
>
>  	  upper_bound(first, end, 11) - first = 5



