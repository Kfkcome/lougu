# 刷算法题总结

## 数组

### 【深基5.例7】工艺品制作 | P5729

第一次错误：范围1< w,x,h <= 20数组大小设置错误设置为了20所以会有RE(RuntimeError)

### [AHOI2001] 彩票摇奖 | P2550

第一次暴力实现4ms暴力实现
其实可以使用号码作为分数下标这样可以快速查找到是否是中奖号码。

第二次用号码作为下标 仍然是4ms改进不大，但是第二次写
把

```C++
int **a=new int *[n];
cin>>n;
```

顺序写反了导致一直RE很难找到错误

### P5730 【深基5.例10】显示屏

看题不仔细，输入输出的格式要仔细看
输出的是大写的X并且其中没有空格，要仔细看
本题没有什么难度和算法

### 梦中的统计 | P1554

一次过

#### 学到新知识：stoi、to_string

![Alt text](image.png)
注意：

1. std::to_string()有9种重载形式，分别对应int/long /long long/unsigned/unsigned long/unsigned long long/float/double/long double。
2. b默认值为10，即10进制；若b = 0，则表示自动确定string序列的基数，如0x7f会自动以16进制为基数。
3. 对于转换为浮点型的字符串(上述表格的最后3个)，可以识别小数点和指数e、E，如std::stod(".3e3")结果为300。
**to_string**例子：

```c++
std::string pi = "pi is " + std::to_string(3.1415926);
std::string perfect = std::to_string(1 + 2 + 4 + 7 + 14) + " is a perfect number";
std::cout << pi << '\n';
std::cout << perfect << '\n';
```

结果：
![At text](image-1.png)
**stoi**例子

```c++
std::string str_dec = "2001, A Space Odyssey";
std::string str_hex = "40c3";
std::string str_bin = "-10010110001";
std::string str_auto = "0x7f";

std::string::size_type sz;   // alias of size_t

//1.转换基数为10进制，sz保存','下标，i_dec = 2001
int i_dec = std::stoi(str_dec, &sz);
//2.转换基数为16进制。所以i_hex = 0x40c3,十进制为16579
int i_hex = std::stoi(str_hex, nullptr, 16);
//3.转换基数为2进制。所以i_bin = -10010110001B,十进制为-1201
int i_bin = std::stoi(str_bin, nullptr, 2);
//4.自动确定 转换基数
int i_auto = std::stoi(str_auto, nullptr, 0);

std::cout << str_dec << ": " << i_dec << " and [" << str_dec.substr(sz) << "]\n";
std::cout << str_hex << ": " << i_hex << '\n';
std::cout << str_bin << ": " << i_bin << '\n';
std::cout << str_auto << ": " << i_auto << '\n';
```

结果：
![Alt text](image-2.png)

### [NOIP2014 普及组] 珠心算测验 | P2141

第一遍过：使用了debug调试发现有一步没有包含在if大括号中间，发现修改后通过
时间复杂度O（3）

可以发现求一个数能否被其他数求和时，每求一个数就要算以下所有其他数能求和出来的数，导致了很多重复的运算

stl set集合使用方法()
集合和

其他方法
优化时间复杂度
使用stl中的集合

### 爱与愁的心痛 | [P1614](https://www.luogu.com.cn/problem/P1614)

第一遍过 ：使用暴力复杂度为O(n*2) 其中有不少重复的运算

求区间的和用前缀和数组来减少时间复杂度

第二遍：使用前缀和数组 ，不过前缀和数组的大小设置的要比原数组的大小大1

例子： 

```c++
    int *a=new int [n+1];
    a[0]=0;//初始化使用前缀和第一个元素为0
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[i]=a[i-1]+a[i];//前缀和实现
    }
```



### 【Mc生存】插火把 | [P1789](https://www.luogu.com.cn/problem/P1789)

第一遍交失败 **数组大小设置没有根据题目的数据范围来设置**

**数组循环的for的条件设置的有问题** 注意for的终止条件

变量命名不要重复尤其是 	i,j,k等

### [USACO1.2] 方块转换 Transformations | [P1205](https://www.luogu.com.cn/problem/P1205)

第一遍交失败：判断if时候条件写错，多种情况混合在了一起，这个不满足时那个可能满足，有一个不满足应该都否定了，但是这样写后，导致互补一会这种情况满足，一会另一种情况满足 **最后好像满足了，实际上都不满足，注意一票否决的情况**

第二遍失败 ：模拟出错注意耐心审题，不能一概而论想像**要实际在脑子中或者手写模拟一下**

## 【算法2-1】前缀和、差分与离散化

### 最大加权矩形 | [P1719](https://www.luogu.com.cn/problem/P1719)

**思路：**使用二维前缀和数组来求解，这样求解二维数组中的片段（子矩阵）的和更加节省时间，然后通过遍历所有子矩阵求出和最大的子矩阵

这题必须写下题解，写了好久找了好久的bug，如果你也卡了很久找不到bug可以看看我的找bug的旅程。

### [NOIP2011 提高组] 聪明的质监员 | [P1314](https://www.luogu.com.cn/problem/P1314)

####　题目

[**题目链接**](https://www.luogu.com.cn/problem/P1314)

####  读题

首先读题大家肯定没有问题，但是我不知道大家有没有注意到一个情况，就是题目给的样例中，矿物是按重量排序大小排序的，就是这一点把我坑惨了，还以为其他测试数据也是如此，就直接默认是有序的然后进行二分搜索发现，一个AC也没有。

> # 样例
> ## **输入**
> ````c++ 
> 5 3 15  
> 1 5 
> 2 5 
> 3 5 
> 4 5 
> 5 5 
> 1 5 
> 2 4 
> 3 3 
> ````
> ## **输出**
> ```c++
> 10
> ````
>

#### 思路

**首先**你可以读题发现，直接通过他给的思路模拟，就是一种办法，本着暴力也是一种解法的态度，写下了第一版代码，就是完全按着题目的介绍来模拟。第一版发现了题目完全可以离散化，就是搜索的时候解的空间是 **符合W标准矿物的个数** ，搜索的时候就遍历这个个数就可以找到最佳答案
![在这里插入图片描述](https://img-blog.csdnimg.cn/96cb09921ac04578b9b9eea783e7414f.png)

**然后**发现可以用二分搜索来优化搜索。
**二分搜索的使用条件一定有一个是 搜索空间是有序的**，这样才能使用二分搜索，所以我**又另开了一个数组**，来存储这个有序的矿物的信息。那为什么要重新开一个数组呢？不是纯纯浪费空间吗？**不！当然不是**，因为题目已经给矿物编好序号了，**如果我打乱重新排序，就会导致后面根据区间来算y就会出错**，这也是非常容易忽略的一点，在很多题目中也容易忽略这一点。
![当时真崩溃](https://img-blog.csdnimg.cn/393a5d83313243a9b48f70922685d9ff.png)
忽略那一点导致AC的还不如之前模拟的，然后才发现那个问题
![离AC又进了一步](https://img-blog.csdnimg.cn/b0d1d3f2034e4a5b835c6ae841b716a1.png)
最后又突然发现这种因为题目有**重叠区间的反复相加求和的操作**，这就构成了使用前缀和数组的前提条件，然后使用前缀和可以只进行一次求前缀和数组的操作，**再求区间的和就只用收尾相减就可以求出区间的和** 大大节省了时间。
![在这里插入图片描述](https://img-blog.csdnimg.cn/4fa75b5306b84aa681f858f26a00eac9.png)
竟然还有一个错，然后仔细检查才发现 是二分搜索的循环判断条件写错了应该是 **>=**
最终可歌可泣终于AC了
![在这里插入图片描述](https://img-blog.csdnimg.cn/326b3d374b144559988d07ee310ad0ee.png)



#### **总结**

算法题就是要多动手，多自己手写，会发现各种各样的问题，只有通过这些问题才能不断进步，不然只是纸上谈兵，空有理论。
算法题还是挺有意思的，要发现其中的乐趣，动力不就源源不断的来了嘛

### 语文成绩 | [P2367](https://www.luogu.com.cn/problem/P2367)

差分数组的基本使用，当有重复对区间操作（加减）的可以使用差分操作。

容易错的bug

```c++
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        a[i]=a[i]-a[i-1];//这里出错了这样构建的差分数组是不对的
        //导致我一直找不到bug 吐了
        //所以还是重新建一个数组为好
    }
```

转换成原数组时容易出的错误

```c++
    for (int i = 1; i <= n; i++)
    {
        a[i]=a[i-1]+b[i];//这里也容易出错如果不更新a[i]则会导致后续结果出错
        mini = min(a[i], mini);
    }
```

### 地毯 | [P3397](https://www.luogu.com.cn/problem/P3397)

经典的二维差分数组的题目，可以用作练手，回顾二维差分数组的核心操作，指定区间的加减，使用O（1）的复杂度。

## 二维前缀和数组

**b [i] [j]表示在i行j列的这个数组的和，**可以通过加减来表示子矩阵的和，然后我们就可以根据这个意义来推导出b [i] [j] 的公式

*b[i] [j]= b[i - 1] [j] + b[i] [j - 1] - b[i - 1] [j - 1] + a[i] [j];*

## 二维差分数组

### 推导公式

  二维差分我们通常称之为差分矩阵。通过结合一维差分我们可以想到，它的作用是可以让某个子矩阵在`O(1)`的时间复杂度内让所有元素都加上`c`。

  而我之前一直都在强调一点——**前缀和与差分是逆运用，二维亦是如此**。

​		**求一个数组的差分，就和将前缀和数组还原成原数组的操作一样**。所以可以了解将前缀和数组还原成原数组的操作，也就是可以推出求原数组的差分数组的过程。二维数组也是如此，所以我们可以通过这种方式来推导出来公式。

先根据二维前缀和数组的公式***b[i] [j]= b[i - 1] [j] + b[i] [j - 1] - b[i - 1] [j - 1] + a[i] [j]***

来推导出a[i] [j]=b[i] [j]-b[i - 1] [j] - b[i] [j - 1] + b[i - 1] [j - 1]  (**a是b的差分数组，b是a的前缀和数组**) , 于是我们就得到了求差分数组的公式: a是原数组 b是a的差分数组

**b[i] [j]=a[i] [j]-a[i - 1] [j] - a[i] [j - 1] + a[i - 1] [j - 1]**

我们也可以分析一下这个式子的意义：b[i] [j] 就是原本a[i] [j]与周围元素的差，然而这个差与一维数组的不尽相同。

```c++
    for (int i = 0; i < m; i++)
    {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        rug[x1][y1]++;
        rug[x2 + 1][y1]--;//注意要加的位置
        rug[x1][y2 + 1]--;//容易出错导致结果不对
        rug[x2 + 1][y2 + 1]++;
    }//执行制定区间的加减操作
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            rug2[i][j] = rug2[i - 1][j] + rug2[i][j - 1] - rug2[i - 1][j - 1] + rug[i][j];//使用前缀和数组还原
            cout << rug2[i][j] << ' ';
        }
        cout << endl;
    }
```




## set（集合）

### 1. 介绍

set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。

即：set里面的元素不重复 且有序

```c++
//头文件
#include<set>
//初始化定义
set<int>se;
```

1. 函数方法

  | 代码                  | 含义                                                                |
  | --------------------- | ------------------------------------------------------------------- |
  | s.begin()             | 返回set容器的第一个元素的地址（迭代器）                             |
  | s.end()               | 返回set容器的最后一个元素的下一个地址（迭代器）                     |
  | s.rbegin()            | 返回逆序迭代器，指向容器元素最后一个位置                            |
  | s.rend()              | 返回逆序迭代器，指向容器第一个元素前面的位置                        |
  | s.clear()             | 删除set容器中的所有的元素,返回unsigned int类型O(N)                  |
  | s.empty()             | 判断set容器是否为空                                                 |
  | s.insert()            | 插入一个元素                                                        |
  | erase(iterator)       | 删除定位器iterator指向的值                                          |
  | erase（first,second） | 删除定位器first和second之间的值                                     |
  | erase(key_value)      | 删除键值key_value的值                                               |
  | s.find(元素)          | 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 |
  | s.lower_bound(k)      | 返回大于等于k的第一个元素的迭代器                                   |
  | s.upper_bound(k)      | 返回大于k的第一个元素的迭代器                                       |

**查找**

   | 代码             | 含义                                                                |
   | ---------------- | ------------------------------------------------------------------- |
   | s.find(元素)     | 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 |
   | s.lower_bound(k) | 返回大于等于k的第一个元素的迭代器                                   |
   | s.upper_bound(k) | 返回大于k的第一个元素的迭代器                                       |

1. 访问
    a.迭代器访问

```c++
for(set<int>::iterator it=s.begin();it!=s.end();it++)
 cout<<*it<<" ";

b.简便的方法

for(auto i : s)
 cout<<i<<endl;

c.访问最后一个元素

//第一种
cout<<*s.rbegin()<<endl;

 //第二种
set<int>::iterator iter = s.end();
iter--;
cout<<(*iter)<<endl; //打印2;

//第三种
cout<<*(--s.end())<<endl;

1. 重载<运算符
//重载<运算符
struct cmp {
    bool operator () (const int& u, const int& v) const
    {
       // return + 返回条件
    }
};
set<int, cmp> se;
```

其它的set
multiset:元素可以重复，且元素有序
unordered_set ：元素无序且只能出现一次
unordered_multiset ： 元素无序可以出现多次

## map(映射)

map不可以<int,char[]>必须<int,string>，map的键值唯一

map.find(key)返回的是iterator，使用