# 刷算法题总结

## CSP 题目

### 202212-1 训练计划 减少重复计算+模拟

这题的70分容易拿，只要的贪心+模拟就可以拿到70分，重点是最后的30分，就是求最晚时间求法。

最短时间的求法只要看被依赖的项目的时间就可以，不用看依赖的项目了，就是求最早时间的相反，但是其中还是有一定的bug容易错的。

一开始以为只要存储被依赖的项目就可以，但是还是根本过不了，

后来才发现被依赖的数量不止一个，就是一个项目可以被多个项目依赖，但是一个项目就只能依赖一个项目。

一开始还以为等价的为只要看被依赖项目的时间谁最长就记录下来，发现根本不行，必须要看被依赖项目的开始时间谁最晚才行。



## 数组

### 【深基5.例7】工艺品制作 | P5729

第一次错误：范围1< w,x,h <= 20数组大小设置错误设置为了20所以会有RE(RuntimeError)

### [AHOI2001] 彩票摇奖 | P2550

第一次暴力实现4ms暴力实现
其实可以使用号码作为分数下标这样可以快速查找到是否是中奖号码。

第二次用号码作为下标 仍然是4ms改进不大，但是第二次写
把

```C++
int **a=new int *[n];
cin>>n;
```

顺序写反了导致一直RE很难找到错误

### P5730 【深基5.例10】显示屏

看题不仔细，输入输出的格式要仔细看
输出的是大写的X并且其中没有空格，要仔细看
本题没有什么难度和算法

### 梦中的统计 | P1554

一次过

#### 学到新知识：stoi、to_string

![Alt text](image.png)
注意：

1. std::to_string()有9种重载形式，分别对应int/long /long long/unsigned/unsigned long/unsigned long long/float/double/long double。
2. b默认值为10，即10进制；若b = 0，则表示自动确定string序列的基数，如0x7f会自动以16进制为基数。
3. 对于转换为浮点型的字符串(上述表格的最后3个)，可以识别小数点和指数e、E，如std::stod(".3e3")结果为300。
**to_string**例子：

```c++
std::string pi = "pi is " + std::to_string(3.1415926);
std::string perfect = std::to_string(1 + 2 + 4 + 7 + 14) + " is a perfect number";
std::cout << pi << '\n';
std::cout << perfect << '\n';
```

结果：
![At text](image-1.png)
**stoi**例子

```c++
std::string str_dec = "2001, A Space Odyssey";
std::string str_hex = "40c3";
std::string str_bin = "-10010110001";
std::string str_auto = "0x7f";

std::string::size_type sz;   // alias of size_t

//1.转换基数为10进制，sz保存','下标，i_dec = 2001
int i_dec = std::stoi(str_dec, &sz);
//2.转换基数为16进制。所以i_hex = 0x40c3,十进制为16579
int i_hex = std::stoi(str_hex, nullptr, 16);
//3.转换基数为2进制。所以i_bin = -10010110001B,十进制为-1201
int i_bin = std::stoi(str_bin, nullptr, 2);
//4.自动确定 转换基数
int i_auto = std::stoi(str_auto, nullptr, 0);

std::cout << str_dec << ": " << i_dec << " and [" << str_dec.substr(sz) << "]\n";
std::cout << str_hex << ": " << i_hex << '\n';
std::cout << str_bin << ": " << i_bin << '\n';
std::cout << str_auto << ": " << i_auto << '\n';
```

结果：
![Alt text](image-2.png)

### [NOIP2014 普及组] 珠心算测验 | P2141

第一遍过：使用了debug调试发现有一步没有包含在if大括号中间，发现修改后通过
时间复杂度O（3）

可以发现求一个数能否被其他数求和时，每求一个数就要算以下所有其他数能求和出来的数，导致了很多重复的运算

stl set集合使用方法()
集合和

其他方法
优化时间复杂度
使用stl中的集合

### 爱与愁的心痛 | [P1614](https://www.luogu.com.cn/problem/P1614)

第一遍过 ：使用暴力复杂度为O(n*2) 其中有不少重复的运算

求区间的和用前缀和数组来减少时间复杂度

第二遍：使用前缀和数组 ，不过前缀和数组的大小设置的要比原数组的大小大1

例子： 

```c++
    int *a=new int [n+1];
    a[0]=0;//初始化使用前缀和第一个元素为0
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[i]=a[i-1]+a[i];//前缀和实现
    }
```



### 【Mc生存】插火把 | [P1789](https://www.luogu.com.cn/problem/P1789)

第一遍交失败 **数组大小设置没有根据题目的数据范围来设置**

**数组循环的for的条件设置的有问题** 注意for的终止条件

变量命名不要重复尤其是 	i,j,k等

### [USACO1.2] 方块转换 Transformations | [P1205](https://www.luogu.com.cn/problem/P1205)

第一遍交失败：判断if时候条件写错，多种情况混合在了一起，这个不满足时那个可能满足，有一个不满足应该都否定了，但是这样写后，导致互补一会这种情况满足，一会另一种情况满足 **最后好像满足了，实际上都不满足，注意一票否决的情况**

第二遍失败 ：模拟出错注意耐心审题，不能一概而论想像**要实际在脑子中或者手写模拟一下**

## 搜索

### [USACO11OPEN] Corn Maze S | [P1825](https://www.luogu.com.cn/problem/P1825) BFS

这题主要就是坑点比较多，写代码并不复杂，算法也不复杂。

首先一看题目DFS（深度优先搜索）好像可以，因为DFS就是模拟奶牛往下走的过程嘛，也不难写然后就有了第一版的代码：

```c++
#include <bits/stdc++.h>
using namespace std;
int N, M;
struct point
{
    int i, j;
};
char place[301][301];
map<char, list<struct point> > transit;
bool path[301][301];
int min_time = 999999;
int start_i, start_j, end_i, end_j;
bool dfs(int count, int i, int j)
{
    // cout << count << ' ' << place[i][j] << ' ' << i << ' ' << j << endl;
    if (place[i][j] == '#' || path[i][j])
    {
        return false;
    }
    if (i == end_i && j == end_j)
    {
        min_time = min(count, min_time);
        return true;
    }
    path[i][j] = true;
    if (place[i][j] >= 'A' && place[i][j] <= 'Z')
    {

        list<struct point>::iterator it1 = transit[place[i][j]].begin();
        for (; it1 != transit[place[i][j]].end(); it1++)
        {
            if ((*it1).i != i && (*it1).j != j)
                dfs(count, (*it1).i, (*it1).j);
        }
    }
    dfs(count + 1, i, j - 1);
    dfs(count + 1, i, j + 1);
    dfs(count + 1, i - 1, j);
    dfs(count + 1, i + 1, j);
    path[i][j] = false;
    return false;
}
int main()
{
    cin >> N >> M;
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= M; j++)
        {
            cin >> place[i][j];
            if (place[i][j] == '@')
            {
                start_i = i;
                start_j = j;
            }
            if (place[i][j] == '=')
            {
                end_i = i;
                end_j = j;
            }
            if (place[i][j] >= 'A' && place[i][j] <= 'Z')
            {
                struct point p = {i, j};
                transit[place[i][j]].insert(transit[place[i][j]].end(), p);
            }
        }
    }
    dfs(0, start_i, start_j);
    cout << min_time;
    return 0;
}
```

![image-20230916104605799](./%E6%80%BB%E7%BB%93.assets/image-20230916104605799.png)

然后就只拿了12分，奇怪了，为什么会这样，明明就是按照题目写的，还有一堆TLE的，索性先不管TLE的先把WA的处理了。

然后发现了第一个bug

```c++
            if ((*it1).i != i && (*it1).j != j)
                dfs(count, (*it1).i, (*it1).j);
```

这里的判断条件写错了，不应该是两个都不相同才转移，（为啥经常犯这种低级错误呢？还特别难找）

改过之后

```c++
            if ((*it1).i != i || (*it1).j != j)
                dfs(count, (*it1).i, (*it1).j);
```

然后结果

![image-20230916105046883](./%E6%80%BB%E7%BB%93.assets/image-20230916105046883.png)

为什么会这样呢？

再去审题就会发现一个**想当然的地方**

> 如果一头奶牛处在这个装置的起点或者终点，这头奶牛就**必须**使用这个装置。

还以为还是可以选择传送或者转移呢，原来是必须要传送啊

此时我又陷入了迷茫，必须要转移的话那是不是会导致一直循环转移啊？还是只能转移一次吗？

然后我无奈之下看了题解

为啥全是BFS（广度优先搜索）啊？？肯定是互相抄的结果，我偏不信邪，就要用DFS来写。

不过还是有收获的可以直接让那个转移，在本层转移

```c++
bool dfs(int count, int i, int j)
{
    if (place[i][j] == '=')
    {
        min_time = min(count, min_time);
        return true;
    }
    if (i > N || i < 1 || j > M || j < 1 || path[i][j] || place[i][j] == '#')
    {
        return false; // 不满足条件直接回溯
    }
    path[i][j] = true; // 初始化条件
    if (place[i][j] >= 'A' && place[i][j] <= 'Z')
    {
        list<struct point>::iterator it1 = transit[place[i][j]].begin();
        for (; it1 != transit[place[i][j]].end(); it1++)
        {
            if ((*it1).i != i || (*it1).j != j)
            {
                i = (*it1).i;
                j = (*it1).j;
                break;
            }
        }
    }
    dfs(count + 1, i + 1, j );
    dfs(count + 1, i - 1, j);
    dfs(count + 1, i, j - 1);
    dfs(count + 1, i, j + 1);
    path[i][j] = false; // 恢复状态
    return false;
}
```

这样不就好了

结果

![image-20230916105806902](./%E6%80%BB%E7%BB%93.assets/image-20230916105806902.png)

为啥还是这样啊？还有WA的啊？

然后我又左思右想，是不是初始化的点不太对啊？回复状态的点也不太对啊？

确实是这样的，我们转移状态后恢复的状态应该是最一开始的点的状态，而不是那个传送点的状态。

至于为什么传送后的点的状态不用的初始化和恢复，因为这个点后边还可以转回来使用

```c++
bool dfs(int count, int i, int j)
{
    int init_i = i, init_j = j;
    if (place[i][j] == '=')
    {
        min_time = min(count, min_time);
        return true;
    }
    if (i > N || i < 1 || j > M || j < 1 || path[i][j] || place[i][j] == '#')
    {
        return false; // 不满足条件直接回溯
    }
    if (place[i][j] >= 'A' && place[i][j] <= 'Z')
    {
        list<struct point>::iterator it1 = transit[place[i][j]].begin();
        for (; it1 != transit[place[i][j]].end(); it1++)
        {
            if ((*it1).i != i || (*it1).j != j)
            {
                i = (*it1).i;
                j = (*it1).j;
                break;
            }
        }
    }
    path[init_i][init_j]=true;  
    if (i + 1 >= 1 && i + 1 <= N && j >= 1 && j <= M && !path[i + 1][j] && place[i + 1][j] != '#')
        dfs(count + 1, i + 1, j);
    if (i - 1 >= 1 && i - 1 <= N && j >= 1 && j <= M && !path[i - 1][j] && place[i - 1][j] != '#')
        dfs(count + 1, i - 1, j);
    if (i >= 1 && i <= N && j - 1 >= 1 && j - 1 <= M && !path[i][j - 1] && place[i][j - 1] != '#')
        dfs(count + 1, i, j - 1);
    if (i >= 1 && i <= N && j + 1 >= 1 && j + 1 <= M && !path[i][j + 1] && place[i][j + 1] != '#')
        dfs(count + 1, i, j + 1);
    path[init_i][init_j] = false; // 恢复状态
    return false;
}
```

我顺便还剪了剪枝

结果

![image-20230916110314903](./%E6%80%BB%E7%BB%93.assets/image-20230916110314903.png)

唉无能为力的，只能放弃DFS了，而且再剪枝也减不了了，因为DFS进行了许多重复运算，要是

我会**记忆深度优先搜索**就好了，那样减少了重复运算没准就可以了。

然后只能转战BFS了

一不小心又出了个错 就是第47行多写的一个等于号，导致只对了37分，改过来后下全对

```c++
#include <bits/stdc++.h>
using namespace std;
int N, M;
struct point
{
    int i, j, c;
};
char place[301][301];
map<char, list<struct point> > transit;
bool path[301][301];
int min_time = 1 << 20;
int temp[4] = {1, 0, -1, 0};
int temp2[4] = {0, 1, 0, -1};
int start_i, start_j;
queue<point> q;

int bfs()
{
    q.push((struct point){start_i, start_j});
    struct point p;
    while (!q.empty())
    {
        p = q.front();
        q.pop();
        if (place[p.i][p.j] == '=')
        {
            return p.c;
        }
        if (place[p.i][p.j] >= 'A' && place[p.i][p.j] <= 'Z')
        {
            list<struct point>::iterator it1 = transit[place[p.i][p.j]].begin();
            for (; it1 != transit[place[p.i][p.j]].end(); it1++)
            {
                if ((*it1).i != p.i || (*it1).j != p.j)
                {
                    p.i = (*it1).i;
                    p.j = (*it1).j;
                    break;
                }
            }
        }
        for (int i = 0; i < 4; i++)
        {
            int x = p.i + temp[i], y = p.j + temp2[i];
            if (place[x][y] != '#' && !path[x][y] && x >= 1 && x <= N && y >= 1 && y <= M)
            {
                path[x][y] = true;
                q.push((point){x, y, p.c + 1});
            }
        }
    }
    return -1;
}
int main()
{
    cin >> N >> M;
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= M; j++)
        {
            cin >> place[i][j];
            if (place[i][j] == '@')
            {
                start_i = i;
                start_j = j;
            }
            else if (place[i][j] >= 'A' && place[i][j] <= 'Z')
            {
                struct point p = {i, j, 0};
                transit[place[i][j]].push_back(p);
            }
        }
    }
    cout << bfs();
    return 0;
}
```

结果：

![image-20230916110810138](./%E6%80%BB%E7%BB%93.assets/image-20230916110810138.png)

#### 总结

这题不难考的就是审题和BFS的书写。

我主要就是老卡在一些审题和小细节的bug 上什么时候我才能养成不出小bug 的能力，和快速检查出bug的能力，其次就是审题要仔细一些，看清楚一些细节再写题。

###　马的遍历 | [P1443](https://www.luogu.com.cn/problem/P1443)　BFS

这题基本上算是宽度优先搜索的模板题了，难度不是很大，只要看好特殊情况，编程少出一些小bug就好了

1. 第一个错误是：没有判断数据越界的情况，
2. 第二个错误是：队列的push应该写在if里
3. 第三个错误是判断越界的情况if的判断范围写错了
4. 第四个错误情况是特殊情况没有考虑正确

最后也是两遍才过，时间也不短，希望以后吸取教训

### [USACO08FEB] Meteor Shower S | [P2895](https://www.luogu.com.cn/problem/P2895) 宽度优先搜索 BFS

只要看到和路径相关的和步数相关的就基本上就是BFS了

这题的难点在于搜索过程中模拟陨石下落的过程，也就是实时更新哪些点可以走，哪些点不能走

1. 忘记了陨石一下要砸四个点
2. 忘记判断数组越界情况
3. 读题没有发现只要走出了300就安全了（看了题解才知道）

总结就是有bug 改不出来一定要仔细读题

##  前缀和、差分与离散化

### 最大加权矩形 | [P1719](https://www.luogu.com.cn/problem/P1719)

**思路：**使用二维前缀和数组来求解，这样求解二维数组中的片段（子矩阵）的和更加节省时间，然后通过遍历所有子矩阵求出和最大的子矩阵

这题必须写下题解，写了好久找了好久的bug，如果你也卡了很久找不到bug可以看看我的找bug的旅程。

### [NOIP2011 提高组] 聪明的质监员 | [P1314](https://www.luogu.com.cn/problem/P1314)

####　题目

[**题目链接**](https://www.luogu.com.cn/problem/P1314)

####  读题

首先读题大家肯定没有问题，但是我不知道大家有没有注意到一个情况，就是题目给的样例中，矿物是按重量排序大小排序的，就是这一点把我坑惨了，还以为其他测试数据也是如此，就直接默认是有序的然后进行二分搜索发现，一个AC也没有。

> # 样例
> ## **输入**
> ````c++ 
> 5 3 15  
> 1 5 
> 2 5 
> 3 5 
> 4 5 
> 5 5 
> 1 5 
> 2 4 
> 3 3 
> ````
> ## **输出**
> ```c++
> 10
> ````
>

#### 思路

**首先**你可以读题发现，直接通过他给的思路模拟，就是一种办法，本着暴力也是一种解法的态度，写下了第一版代码，就是完全按着题目的介绍来模拟。第一版发现了题目完全可以离散化，就是搜索的时候解的空间是 **符合W标准矿物的个数** ，搜索的时候就遍历这个个数就可以找到最佳答案
![在这里插入图片描述](https://img-blog.csdnimg.cn/96cb09921ac04578b9b9eea783e7414f.png)

**然后**发现可以用二分搜索来优化搜索。
**二分搜索的使用条件一定有一个是 搜索空间是有序的**，这样才能使用二分搜索，所以我**又另开了一个数组**，来存储这个有序的矿物的信息。那为什么要重新开一个数组呢？不是纯纯浪费空间吗？**不！当然不是**，因为题目已经给矿物编好序号了，**如果我打乱重新排序，就会导致后面根据区间来算y就会出错**，这也是非常容易忽略的一点，在很多题目中也容易忽略这一点。
![当时真崩溃](https://img-blog.csdnimg.cn/393a5d83313243a9b48f70922685d9ff.png)
忽略那一点导致AC的还不如之前模拟的，然后才发现那个问题
![离AC又进了一步](https://img-blog.csdnimg.cn/b0d1d3f2034e4a5b835c6ae841b716a1.png)
最后又突然发现这种因为题目有**重叠区间的反复相加求和的操作**，这就构成了使用前缀和数组的前提条件，然后使用前缀和可以只进行一次求前缀和数组的操作，**再求区间的和就只用收尾相减就可以求出区间的和** 大大节省了时间。
![在这里插入图片描述](https://img-blog.csdnimg.cn/4fa75b5306b84aa681f858f26a00eac9.png)
竟然还有一个错，然后仔细检查才发现 是二分搜索的循环判断条件写错了应该是 **>=**
最终可歌可泣终于AC了
![在这里插入图片描述](https://img-blog.csdnimg.cn/326b3d374b144559988d07ee310ad0ee.png)



#### **总结**

算法题就是要多动手，多自己手写，会发现各种各样的问题，只有通过这些问题才能不断进步，不然只是纸上谈兵，空有理论。
算法题还是挺有意思的，要发现其中的乐趣，动力不就源源不断的来了嘛

### 语文成绩 | [P2367](https://www.luogu.com.cn/problem/P2367)

差分数组的基本使用，当有重复对区间操作（加减）的可以使用差分操作。

容易错的bug

```c++
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        a[i]=a[i]-a[i-1];//这里出错了这样构建的差分数组是不对的
        //导致我一直找不到bug 吐了
        //所以还是重新建一个数组为好
    }
```

转换成原数组时容易出的错误

```c++
    for (int i = 1; i <= n; i++)
    {
        a[i]=a[i-1]+b[i];//这里也容易出错如果不更新a[i]则会导致后续结果出错
        mini = min(a[i], mini);
    }
```

### 地毯 | [P3397](https://www.luogu.com.cn/problem/P3397)

经典的二维差分数组的题目，可以用作练手，回顾二维差分数组的核心操作，指定区间的加减，使用O（1）的复杂度。

### [NOI2015] 程序自动分析 | [P1955](https://www.luogu.com.cn/problem/P1955) 并查集+离散化

经典并查集+离散化

#### 离散化的三步：

**1.去重（可以用到unique去重函数）**

**2.排序**

**3.二分索引（可以用到lower_bound函数）**

#### 并查集的操作：

查询、融合、初始化

#### 代码	

```c++
#include <bits/stdc++.h>
using namespace std;
int pre[1000007], book[1000007 * 3];
struct node
{
    int a, b, e;
};
struct node ne[1000001];
int find(int x)
{
    if (pre[x] != x)
        return pre[x] = find(pre[x]);
    return x;
} // 并查集查询
void join(int x, int y)
{
    pre[find(y)] = find(x);
} // 并查集融合
inline void first(int kkk)
{
    for (int i = 0; i <= kkk; i++)
        pre[i] = i;
} // 初 始 化
bool cmp(node a, node b)
{
    return a.e > b.e;
}
int main()
{
    int t;
    cin >> t;
    for (int j = 0; j < t; j++)
    {
        memset(book,0,sizeof(book));
        memset(ne,0,sizeof(ne));
        memset(pre,0,sizeof(pre));
        int n, pol = -1;
        cin >> n;
        bool flag = false;
        for (int i = 1; i <= n; i++)
        {
            int a, b, e;
            cin >> ne[i].a >> ne[i].b >> ne[i].e;
            book[++pol] = ne[i].a;
            book[++pol] = ne[i].b;
        }
        sort(book, book + pol + 1);
        int uni = unique(book, book + pol + 1) - book;
        first(uni); // 初始化pre数组  注意这里初始化的大小要根据有多少个不同数来初始化，这里卡了半天，因为这个是根据离散化后的最大数值来的，最大数值就是uni
        for (int i = 1; i <= n; i++)
        {
            ne[i].a = lower_bound(book, book + uni, ne[i].a) - book;
            ne[i].b = lower_bound(book, book + uni, ne[i].b) - book;
        }
        sort(ne + 1, ne + 1 + n, cmp);
        for (int i = 1; i <= n; i++)
        {
            int p1 = find(ne[i].a);
            int p2 = find(ne[i].b);
            if (ne[i].e) // 如果相等的话，就让两者合并入一个集合，如果在同一个集合中也不影响
            {
                pre[p1]=p2;
            }
            else
            { // 如果不相等的话判断是不是在一个集合中如果是则不满足条件
                if (p1 == p2)
                {
                    flag = true;
                    break;
                }
            }
        }
        if (flag)
        {
            cout << "NO" << endl;
        }
        else
            cout << "YES" << endl;
    }
    return 0;
}
```

### 领地选择 | [P2004](https://www.luogu.com.cn/problem/P2004)

求最优解之前，初始化的不能是自己任意设计的最小值，而是要从可行解中找到任意一个解，这样在比较中才能求到是可行解之中的，不然可能会出现不在可行解的范围内。

```c++
    int value=m[1+C-1][1+C-1]-m[1+C-1][1-1]-m[1-1][1+C-1]+m[1-1][1-1];//初始化 
//不行初始化为 int value=-1<<25  虽然已经小了但是不是可行解范围内的导致最后求出来的解不是可行解
    int x=1,y=1;//同样使用可行解
```

## 二分

### CSP 202303-1二分搜索

这里check函数没有写好的，导致结果一直不多对，如果结果不对的话需要检查check函数的编写逻辑是否正确。

### [COCI2011-2012#5] EKO / 砍树（二分答案） | [P1873](https://www.luogu.com.cn/problem/P1873)

使用二分答案解题：使用二分搜索时要看是，满足条件的解**尽量往右找还是尽量往左找**，对应使用不同的模版。

### [NOIP2001 提高组] 一元三次方程求解 | [P1024](https://www.luogu.com.cn/problem/P1024)

二分搜索的时候，一定要确定好判断条件和区间，然后再是，如果卡住就重新审题，这题是因为没有审清题目，变量是double而不是int

### 烦恼的高考志愿 | [P1678](https://www.luogu.com.cn/problem/P1678)

二分搜索：确定尽量往左求还是右求，但是求出来的一定**是大于等于，不可能是小于**，最后要注意判断条件

```c++
    for (int i = 0; i < n; i++)
    {
        int temp = binSearch(s[i]);

        int split1 = abs(s[i] - t[temp]);

        int split2 = abs(temp - 1 >= 0 ? s[i] - t[temp - 1] : 1 << 30);//这里temp的范围出错了写成了temp>0找了好久好久。
        sum += min(split1, split2);
    }
```

### [NOIP2015 提高组] 跳石头 | [P2678](https://www.luogu.com.cn/problem/P2678)

使用二分答案求解，第一次过10% ，模拟**消除岩石的时候出错**，消除岩石后应该是也可能影响后边导致后边的变化，然后就是二分的判断条件出错导致不是**尽量向左寻找**。这里数据结构使用了链表，一开始使用数据值错误的。最后20%是边界问题，L,M,N的范围中都有可能是零，这种极端情况没有考虑到。

### 数列分段 Section II | [P1182](https://www.luogu.com.cn/problem/P1182)

使用二分搜索+贪心算法求出来，重点是贪心算法想不到，求一个数组的连续最大和的最小值，可以从一开始然后遍历到最后，如果大于的那个最小值，则新开一个子数组，然后就可以看到需要分多少个子数组了。

没想到贪心的原因：不知道从何入手，不知道该怎么遍历所有解，**还有就是没有确定好check函数的功能**，是检测一个解可不可行，而不是用贪心一下求出来，而是用贪心的策略，检测可不可行，需要用划分多少个子数组，**想要用最少个子数组来达到目的，不就是贪心吗？**

### [USACO07MAR] Face The Right Way G | [P2882](https://www.luogu.com.cn/problem/P2882)

这题主要卡住的地方是**贪心**和**前缀和**的应用（本来这题就考这两点结果一个也没想起来）

贪心的应用就是碰见一个**不为朝前的牛就让他后边的K个全部反转**，最终这样会求出来当前K值下最小的操作数（不知道为啥没想到，可能是没有从一般的人工的方法中抽象出来一般的方法策略）

然后前缀和就是用一个前缀和数组来记录第i个奶牛的反转次数，这个我是想到了的，但是我没想到，用一个变量来存当前前缀和的和，也就是当前第i个奶牛的反转次数，光想着要求当前奶牛的反转次数就要重新从头开始累加求前缀和（根本没有意识到，这些求和是重复的工作），前缀和的算法的**最核心的思想就是保存之前的值，然后减少重复求和，**没有把握好核心思想光生搬硬套了。

### [Poetize6] IncDec Sequence | [P4552](https://www.luogu.com.cn/problem/P4552)

这题虽然知道要用前缀和和差分来优化，但是没想到要**完全用差分来解题**，虽然题目中涉及到了区间操作，我只想着把差分来转换区间操作，但是这样是不完全的，因为差分就是每个元素之间的差，我们可以让这个差为零**也就是差分数组的每一项都为零**，就可以达到题目条件

其次就是种类数，因为种类数是和差分数组的第一个元素的值有关，如果我们把单个**的减少或增加与第一个元素联系起来然**后我们就可以实现了对第一个 元素的改变，最终实现的求出种类数。

这题关键不能陷入了平常让所有数相同的一般思维，要用**差分的思想**，将题目转换为了一般的容易思考的，所以首先要转换问题，然后再求解。

### [USACO11NOV] Cow Lineup S | [P3029](https://www.luogu.com.cn/problem/P3029)

**离散化+双指针+map+set:**

首先离散化很容易就想到了，但是**双指针（普通指针也就两个指针往同一方向前进）**不好想，因为**要是使用到map数据结构来保存照片中的各个种类的个数，**首先要从开头开始想，r=2,l=1时用什么策略去移动指针，然后在想到策略是如果可以减少重复的种类的个数，就可以让左边的指针前移，然后右边的指针要遍历的前移，左边的是看情况前移。

重温map的使用方法。

### [CEOI1999] Parity Game | [P5937](https://www.luogu.com.cn/problem/P5937) 前缀和+离散化+并查集

这题首先卡住我是如何是使用并查集，离散化不难想到，重点是**前缀和和并查集**。

首先**一看到是片段操作，就应该想到前缀和和差分**，因为这两个操作是与区间操作十分相关的技术，然后我们就可以发现一个规律：**就是一个区间含1的个数只与开始和结尾的元素有关**，我们只用判断开始和结尾的元素的奇偶性想不相同就可以判断区间的奇偶性。

然后我们在想到并查集，而且是**扩区域的并查集**，什么意思呢？就是在并查集的基础上多加几个集合，就是一个元素有多个集合要存，就像这题既要**保存奇偶性相同的，也要保存与他奇偶性不相同的**。也就是两个完全不同并查集的树，来保存这两个集合。

## 动态规划



### [NOIP1996 提高组] 挖地雷 | [P2196](https://www.luogu.com.cn/problem/P2196) 动态规划

这题一开始知道是动态规划但是没有想到**如何将问题分解为小问题**，也就是不知道如何求出**递推表达式**，可能还是没有掌握动态规划的精髓。

这题应该将$dp_i$设置为**以i为终点的路径的总权**，然后第二层**for是寻找这个终点的前一个点（要保证这个点最大**），然后第一层for是寻找出，**所有点为终点的结果，**然后就是使用数组来保存路径

然后中间出了一个小bug（也找了很久）

**因为找最大值时设置的初值不对然后就导致极端情况下用的初值**，然后导致情况出错以后要注意

### [SHOI2002] 滑雪 | [P1434](https://www.luogu.com.cn/problem/P1434) 动态规划/无后效性

#### 无后效性

**已经求解的子问题，不会再受到后续决策的影响。**

这题的动态规划很容易想到但是问题是**如何解决无后效性**成为了问题的关键。

动态规划的递推公式是

$$\huge dp_{ij}=max(dp_{i-1,j},dp_{i,j-1},dp_{i+1,j},dp_{i,j+1})+1$$

然后就是以什么样的顺序来求解$dp_{ij}$， 然后考虑到动态规划要求的无后效性，我们是使用先讲高度地点地方的$dp_{ij}$算出来，逐渐到最大的height的$dp_{ij}$，最终求得最优解问题。

### 最大食物链计数 | [P4017](https://www.luogu.com.cn/problem/P4017) 动态规划+拓扑排序+队列

这题动态规划容易想到，但是由于**动态规划要求无后效性**，所以我们求解的顺序就要以一个特定的顺序，不像前一问可以直接用排序解决无后效性这个问题，因为是图论的问题，我们要使用到**拓扑排序**，来确定出子问题的求解顺序（不看题解谁想的出来的啊）

这题的卡点，首先是读题 

1. 求的是最大食物链的数量而不是长度
2. 因为数很大所以要**一开始就要求模在过程中就要求模**,不然回导致过大而超出空间。
3. 还有就是要使用**队列**这个数据结构,使用stl，然后就挺方便的。
4. 还有要注意分清吃与被吃的关系，有向图的边要搞清楚，入度和出度分别代表什么含义要搞清楚。
5. 还有就是dp的初始化，**题目没有说生产者和最优捕食者只有一个，**所以我们要对所有的入度为零的dp初始化，（这个最后卡了我很久，以后要加强读题）

### 最大子段和 | [P1115](https://www.luogu.com.cn/problem/P1115)　动态规划＋滚动数组

这题也是经典的动态规划，不过和前面两个题的动态规划还不太一样，因为前面两个动态规划是**以解决题目的问题为最大解的**，也就是说上面两题最终求出来的dp直接就是问题的解，因为分解的过程是把求解的规模逐渐变大然后**把最终的问题的解寄托于最后求得的那个dp**，然而这个问题并不是这样。这个问题是求出诸多个解（也就是多个连续子序列片段和）然后通过比较求出最大值。

$\huge dp_i$的含义是以第i个数结尾的最大连续子序列的和的最大值

递推公式 ：$\huge dp_i=max(dp_{i-1}+a_i,a_i)$

而不是我想的$\huge dp_i$是第0个数到第i个数的最大连续子序列的和，这样虽然是直接对问题规模的小化和求解，但是这样求解不出来，因为没办法递归求下去，前一个问题的解和后一个问题解不相关。不符合**子问题重叠**和**最优子结构**的动态规划特性

### 疯狂的采药 | [P1616](https://www.luogu.com.cn/problem/P1616) 动态规划：完全背包问题模板

这题是经典的完全背包问题

重点理解完全背包问题的递推公式：
$$
f_{ij}=max(f_{i-1,j},f_{i,j-w_i}+v_i)
$$
求解物品选多少个时：不是从$f_{i-1}$状态推出，因为有重复的计算，要从$f_{i}$第i物品j-1个 导出。

**dp数组记得用long**

### 小A点菜 | [P1164](https://www.luogu.com.cn/problem/P1164)动态规划+边界初始值设置

第一次提交：看错题你以为是最大的订菜数量，**应该是订菜的策略的数量**

第二次提交：状态转移方程错误

错误：
$$
f_{ij}=max(f_{i-1,j-a[i]}+1,f_{i-1,j})
$$
第三次提交：

以为策略是两者的最大值，**实际上没有搞清楚的$f_{ij}$的含义**

错误：
$$
f_{i,j}=max(f_{i,j-a[i]},f_{i-1,j})
$$
第四次提交看题解：
$$
f_{ij}=f_{i-1,j-a[i]}+f_{i-1,j}
$$
初始情况设置：

```c++
    for (int j = 1; j <= M; j++)
    {
        for (int i = 1; i <= N; i++)
        {
            if (a[i]==j)
            {
                dp[j][i]=dp[j][i-1]+1;
            }
            else if (j > a[i])
                dp[j][i] = dp[j-a[i]][i - 1]+dp[j][i-1];
            else
                dp[j][i] = dp[j][i - 1]; 
        }
    }
```

### [NOIP2012 普及组] 摆花 | [P1077](https://www.luogu.com.cn/problem/P1077)动态规划

多重背包问题

$dp_{ij}$表示有i种花，容量为j下的策略的数量

**最重要的是初始值的设置**

**$dp_{00}=1$**

状态转移方程：
$$
dp_{ij}+=dp_{i-1,j-k}
$$
k是第i种花选取的数量

最终可以得到n种花容量为m的最大策略数量

### kkksc03考前临时抱佛脚 | [P2392](https://www.luogu.com.cn/problem/P2392) 动态规划+应用实际+倒序

首先能否想到这是一个背包问题就是一个难点，因为是左右脑并行的，然后所有的题目又是一定要完成的，所以有一个限制条件，左右脑完成的题目的时间的和是一定的，所以确定一个脑完成的内容另一个脑袋要完成的内容也就确认了，所以可以简化为背包问题。

**其次就是如果最大的时间也确定了是$\frac{t}{2}$也就是容量，让最后的dp无线接近时间最短然后就好了。**

然后还有一个bug就是，**如果用一维dp数组优化空间的话，我们就需要从后往前遍历**，因为这样保证dp计算用的是前一个状态的dp而不是这一个状态的dp。

### [NOIP2006 提高组] 金明的预算方案 | [P1064](https://www.luogu.com.cn/problem/P1064)

动态规划，这题是比较复杂的递推公式。

这题是通过简化题目，**因为一个主件最多只有三个附件，所以我们可以遍历每一种情况，**然后再使用dp，转换成了经典的背包问题。

**用一维dp优化空间时要从后往前推进，这样保证用的是上一个状态的dp**

其次就是**如果用一维dp数组优化空间的话，我们就需要从后往前遍历**，因为这样保证dp计算用的是前一个状态的dp而不是这一个状态的dp，**如果是同一层的dp的话，那样的就会导致同一个物品多次选的结果**。



我们可以发现一般的dp出题不会直接给一个符合经典dp问题的，都会要是简化一下，然后再迁移一下才能用dp做，就像P1064需要一个遍历，P2392需要将一个两个脑袋转换为一个脑袋的问题。

### [TJOI2007] 线段 | [P3842](https://www.luogu.com.cn/problem/P3842)

这题也是一个看似可以贪心的问题但是实践上一个子问题的最优解并不是全局的最优解，所以还得是动态规划。但是**怎么用动态规划也是要转一个弯**。

如果直接用动态规划的话时间复杂度是$O(n^2)$这样会直接超时

这时我们可以想着简化一下dp，因为下一行的dp仅仅用的到**上一行线段两边端点的dp**所以我们就简化了dp的维数并且简化了dp的时间复杂度。

## 二维前缀和数组

**b [i] [j]表示在i行j列的这个数组的和，**可以通过加减来表示子矩阵的和，然后我们就可以根据这个意义来推导出b [i] [j] 的公式

*b[i] [j]= b[i - 1] [j] + b[i] [j - 1] - b[i - 1] [j - 1] + a[i] [j];*

## 二维差分数组

### 推导公式

  二维差分我们通常称之为差分矩阵。通过结合一维差分我们可以想到，它的作用是可以让某个子矩阵在`O(1)`的时间复杂度内让所有元素都加上`c`。

  而我之前一直都在强调一点——**前缀和与差分是逆运用，二维亦是如此**。

​		**求一个数组的差分，就和将前缀和数组还原成原数组的操作一样**。所以可以了解将前缀和数组还原成原数组的操作，也就是可以推出求原数组的差分数组的过程。二维数组也是如此，所以我们可以通过这种方式来推导出来公式。

先根据二维前缀和数组的公式***b[i] [j]= b[i - 1] [j] + b[i] [j - 1] - b[i - 1] [j - 1] + a[i] [j]***

来推导出a[i] [j]=b[i] [j]-b[i - 1] [j] - b[i] [j - 1] + b[i - 1] [j - 1]  (**a是b的差分数组，b是a的前缀和数组**) , 于是我们就得到了求差分数组的公式: a是原数组 b是a的差分数组

**b[i] [j]=a[i] [j]-a[i - 1] [j] - a[i] [j - 1] + a[i - 1] [j - 1]**

我们也可以分析一下这个式子的意义：b[i] [j] 就是原本a[i] [j]与周围元素的差，然而这个差与一维数组的不尽相同。

```c++
    for (int i = 0; i < m; i++)
    {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        rug[x1][y1]++;
        rug[x2 + 1][y1]--;//注意要加的位置
        rug[x1][y2 + 1]--;//容易出错导致结果不对
        rug[x2 + 1][y2 + 1]++;
    }//执行制定区间的加减操作
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            rug2[i][j] = rug2[i - 1][j] + rug2[i][j - 1] - rug2[i - 1][j - 1] + rug[i][j];//使用前缀和数组还原
            cout << rug2[i][j] << ' ';
        }
        cout << endl;
    }
```

## 二分答案（二分搜索的一种）

题目的可行解在一个范围区间内，这个区间太大导致直接遍历会超时，然后就需要用**二分搜索**，适用情况：

> ###### 1、答案在一个区间内（一般情况下，区间会很大，暴力超时）
>
> ###### 2、直接搜索不好搜，但是容易判断一个答案可行不可行
>
> ###### 3、该区间对题目具有单调性，即：在区间中的值越大或越小，题目中的某个量对应增加或减少。

此外，可能还会有一个典型的特征：求...最大值的最小 、 求...最小值的最大。
1、求...最大值的最小，我们二分答案（即二分最大值）的时候，判断条件满足后，尽量让答案往前来（即：让r=mid），**对应模板1；**
2、同样，求...最小值的最大时，我们二分答案（即二分最小值）的时候，判断条件满足后，尽量让答案往后走（即：让l=mid）**，对应模板2；**

模板1：尽量往左找目标

```c++
	while (l < r)
    {
        int mid = l + r >> 1;	//(l+r)/2
        if (check(mid))  r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
```

模板2：尽量往右找目标。

```c++
	while (l < r)
    {
        int mid = l + r + 1 >> 1;	//(l+r+1)/2
        if (check(mid))  l = mid;
        else r = mid - 1;
    }
```

**只要是往左找答案，就用第一个模板，mid不用加一，r=mid，l加一；
只要是往右找答案，就用第二个模板，mid要加一，l=mid，r要减一；**

## 动态规划



### 基本思想



现在把动态规划方法的基本思想归纳如下。 

(1 ) 动态规划方法的关键在于正确地写出基本的递推关系式和恰当的边界条件( 简言之为基本方程)。要做到这一点, 必须先将问题的过程分成几个相互联系的阶段, 恰当地选取状态变量和决策变量及定义最优值函数, 从而把一个大问题化成一族同类型的子问题,然后逐个求解。即从边界条件开始, 逐段递推寻优,在每一个子问题的求解中, 均利用了它前面的子问题的最优化结果,依次进行, 最后一个子问题所得的最优解,就是整个问题的最优解。

(2 ) 在多阶段决策过程中, 动态规划方法是既把当前一段和未来各段分开, 又把当前效益和未来效益结合起来考虑的一种最优化方法。因此, 每段决策的选取是从全局来考虑的,与该段的最优选择答案一般是不同的。 

(3 ) 在求整个问题的最优策略时, 由于初始状态是已知的,而每段的决策都是该段状态的函数,故最优策略所经过的各段状态便可逐次变换得到, 从而确定了最优路线。 

###　建立模型

在明确了动态规划的基本概念和基本思想之后,我们看到, 给一个实际问题建立动态 

规划模型时,必须做到下面五点: 

(1 ) 将问题的过程划分成恰当的阶段; 

(2 ) 正确选择状态变量 $s_k$ , 使它既能描述过程的演变,又要满足无后效性; 

(3 ) 确定决策变量 $u_k$ 及每阶段的允许决策集合 $D_k(S_k)$; 

(4 ) 正确写出状态转移方程; 

(5 ) 正确写出指标函数 $V_{k,n}$, *n*的关系,它应满足下面三个性质: 

① 是定义在全过程和所有后部子过程上的数量函数; 

② 要具有可分离性,并满足递推关系。即 

$\huge V_{k, n}( s_k ,k_k , …, s_{n+1}) =ψ […, *s**n* + 1 ) ] $

③ 函数 ψ

*k* ( *s**k* , *u**k* , *V**k* + 1 , *n* ) 对于变量 *V**k* + 1 , *n*要严格单调

###  与静态规划的区别

动态规划、线性规划和非线性规划都是属于数学规划的范围, 所研究的对象**本质上都是一个求极值的问题,**都是利用**迭代法去逐步求解的**。不过, **线性规划和非线性规划所研究的问题,通常是与时间无关的**, 故又称它们为静态规划。**线性规划迭代中的每一步是就问题的整体加以改善的**。

而动态规划所研究的问题是与时间有关的, 它是研究具有**多阶段决策过程的一类问题,将问题的整体按时间或空间的特征而分成若干个前后衔接的时空阶段,把多阶段决策问题表示为前后有关联的一系列单阶段决策问题, 然后逐个加以解决,从而求出了整个问题的最优决策序列。**因此, 对于某些静态的问题, 也可以人为地引入时间因素,把它看作是按阶段进行的一个动态规划问题, 这就使得动态规划成为求解某 些线性、非线性规划的有效方法。

### 逆推解法

设已知初始状态为 *s*1 ,并假定最优值函数 $f_k(s_k)$表示第 *k* 阶段的初始状态为 *s**k* , 从 *k*阶段到 *n* 阶段所得到的最大效益。 

### 0-1背包问题

例题中已知条件有第 $i$ 个物品的重量 $w_{i}$，价值 $v_{i}$，以及背包的总容量 $W$。

设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。

考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$；当其放入背包时，背包的剩余容量会减小 $w_{i}$，背包中物品的总价值会增大 $v_{i}$，故这种情况的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$。

由此可以得出状态转移方程：

$$
f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})
$$

这里如果直接采用二维数组对状态进行记录，会出现 MLE。可以考虑改用滚动数组的形式来优化。

由于对 $f_i$ 有影响的只有 $f_{i-1}$，可以去掉第一维，直接用 $f_{i}$ 来表示处理到当前物品时背包容量为 $i$ 的最大价值，得出以下方程：

$$
f_j=\max \left(f_j,f_{j-w_i}+v_i\right)
$$

**务必牢记并理解这个转移方程，因为大部分背包问题的转移方程都是在此基础上推导出来的。**



### 完全背包问题

完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。

我们可以借鉴 0-1 背包的思路，进行状态定义：设 $f_{i,j}$ 为只能选前 $i$ 个物品时，容量为 $j$ 的背包可以达到的最大价值。

需要注意的是，虽然定义与 0-1 背包类似，但是其状态转移方程与 0-1 背包并不相同。

### 过程

可以考虑一个朴素的做法：对于第 $i$ 件物品，枚举其选了多少个来转移。这样做的时间复杂度是 $O(n^3)$ 的。

状态转移方程如下：

$$
f_{i,j}=\max_{k=0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)
$$

考虑做一个简单的优化。可以发现，对于 $f_{i,j}$，只要通过 $f_{i,j-w_i}$ 转移就可以了。因此状态转移方程为：

$$
f_{i,j}=\max(f_{i-1,j},f_{i,j-w_i}+v_i)
$$

理由是当我们**这样转移时，$f_{i,j-w_i}$ 已经由 $f_{i,j-2\times w_i}$ 更新过，那么 $f_{i,j-w_i}$ 就是充分考虑了第 $i$ 件物品所选次数后得到的最优结果。**换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。

与 0-1 背包相同，我们可以将第一维去掉来优化空间复杂度。如果理解了 0-1 背包的优化方式，就不难明白压缩后的循环是正向的（也就是上文中提到的错误优化）。

### 多重背包问题





## sort函数
一、sort函数调用的两种方式
方式一(默认)	

```c++
void sort (RandomAccessIterator first, RandomAccessIterator last);
```

方式二(自定义):	

```c++
void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
```

默认: 两个参数first,last，将 **[first, last)**区间内元素升序排列。**【注意区间为左闭右开】**

自定义排序: 需用户指定排序规则Compare comp,将 **[first, last)**区间内的元素按照用户指定的顺序排列。

## list(链表)

### list的介绍

1. list是序列容器，允许在序列中的任何位置执行固定O(1)时间复杂度的插入和删除操作，并在两个方向进行迭代。

2. list容器使用双链表实现；双链表将每个元素存储在不同的位置，每个节点通过next，prev指针链接成顺序表。

3. list与其他标准序列容器（array，vector和deque）相比，list通常可以在容器内的任何位置插入、提取和移动元素。

4. list与其他标准序列容器（array，vector和deque）相比，list和forward_list（单链表实现）的主要缺点是他们不能通过位置直接访问元素；例如，要访问列表中的第五个元素，必须从已知位置（开始或结束）迭代到该位置，需要哦线性时间开销。

5. 存储密度低，list要使用一些额外的内容空间（next，prev）来保持与每个元素相关联（前后续的线性）的链接信息，从而导致存储小元素类型（如char，short，int等）的列表的存储密度低。

   

### list的插入



| 修改器                                                       | 功能                                            |
| ------------------------------------------------------------ | :---------------------------------------------- |
| void clear();                                                | 从容器擦除所有元素。此调用后 size() 返回零。    |
| iterator insert( iterator pos, const T& value )              | 在 pos 前插入 value 。                          |
| void insert( iterator pos, size_type count, const T& value ); | 在 pos 前插入 value 的 count 个副本。           |
| void **insert**( iterator pos, InputIt first, InputIt last); | 在 pos 前插入来自范围 [first, last) 的元素      |
| iterator **insert**( const_iterator pos, std::initializer_list ilist ); | 在 pos 前插入来自 initializer_list ilist 的元素 |
| iterator **erase**( iterator pos );                          | 移除位于 pos 的元素。                           |
| iterator **erase**( iterator first, iterator last );         | 移除范围 [first; last) 中的元素。               |
| void **pop_back**();                                         | 移除容器的末元素。                              |
| void **push_front**( const T& value );                       | 前附给定元素 value 到容器起始。                 |
|                                                              |                                                 |
|                                                              |                                                 |
|                                                              |                                                 |
|                                                              |                                                 |
|                                                              |                                                 |
|                                                              |                                                 |
|                                                              |                                                 |

## set（集合）

### 1. 介绍

set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。

即：set里面的元素不重复 且有序

```c++
//头文件
#include<set>
//初始化定义
set<int>se;
```

1. 函数方法

  | 代码                  | 含义                                                                |
  | --------------------- | ------------------------------------------------------------------- |
  | s.begin()             | 返回set容器的第一个元素的地址（迭代器）                             |
  | s.end()               | 返回set容器的最后一个元素的下一个地址（迭代器）                     |
  | s.rbegin()            | 返回逆序迭代器，指向容器元素最后一个位置                            |
  | s.rend()              | 返回逆序迭代器，指向容器第一个元素前面的位置                        |
  | s.clear()             | 删除set容器中的所有的元素,返回unsigned int类型O(N)                  |
  | s.empty()             | 判断set容器是否为空                                                 |
  | s.insert()            | 插入一个元素                                                        |
  | erase(iterator)       | 删除定位器iterator指向的值                                          |
  | erase（first,second） | 删除定位器first和second之间的值                                     |
  | erase(key_value)      | 删除键值key_value的值                                               |
  | s.find(元素)          | 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 |
  | s.lower_bound(k)      | 返回大于等于k的第一个元素的迭代器                                   |
  | s.upper_bound(k)      | 返回大于k的第一个元素的迭代器                                       |

**查找**

   | 代码             | 含义                                                                |
   | ---------------- | ------------------------------------------------------------------- |
   | s.find(元素)     | 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 |
   | s.lower_bound(k) | 返回大于等于k的第一个元素的迭代器                                   |
   | s.upper_bound(k) | 返回大于k的第一个元素的迭代器                                       |

1. 访问
    a.迭代器访问

```c++
for(set<int>::iterator it=s.begin();it!=s.end();it++)
 cout<<*it<<" ";

b.简便的方法

for(auto i : s)
 cout<<i<<endl;

c.访问最后一个元素

//第一种
cout<<*s.rbegin()<<endl;

 //第二种
set<int>::iterator iter = s.end();
iter--;
cout<<(*iter)<<endl; //打印2;

//第三种
cout<<*(--s.end())<<endl;

1. 重载<运算符
//重载<运算符
struct cmp {
    bool operator () (const int& u, const int& v) const
    {
       // return + 返回条件
    }
};
set<int, cmp> se;
```

其它的set
multiset:元素可以重复，且元素有序
unordered_set ：元素无序且只能出现一次
unordered_multiset ： 元素无序可以出现多次

## map(映射)

**map不可以<int,char[]>必须<int,string>，map的键值唯一**

### map容器内元素的访问

map 一般有两种访问方式∶通过下标访问或通过迭代器访问。下面分别讨论这两种访问方式。

**（1）通过下标访问**

和访问普通的数组是一样的，例如对一个定义为 map<char，int> mp 的map 来说，就可以直接使用 mp[‘c’]的方式来访问它对应的整数。于是，当建立映射时，就可以直接使用mp[‘c’]=20 这样和普通数组一样的方式。但是要注意的是，map中的键是唯一的，也就是说，下面的代码将输出30∶

```c++
#include<iostream>
#include<map>
using namespace std;
//map
int main()
{
	map<char,int> mp;
	mp['c'] = 20;
	mp['c'] = 30; // 20被覆盖	

	cout << mp['c'] << endl;
	
	return 0;
}
```


输出结果：

30
**（2）通过迭代器访问**

map 迭代器的定义和其他 STL 容器迭代器定义的方式相同∶

```c++
map<typenamel,typename2>::iterator it;
```


typename1和typename2就是定义 map 时填写的类型，这样就得到了迭代器it。map 迭代器的使用方式和其他 STL 容器的迭代器不同，因为 map 的每一对映射都有两个typename，这决定了必须能通过一个 it 来同时访问键和值。事实上，map可以使用 it->first 来访问键，使用 it->second 来访问值。

```c++
#include<iostream>
#include<map>

using namespace std;

//通过迭代器访问
//it -> first访问键
//it -> second访问值 
int main()
{
	map<char,int> mp;
	

	mp['m'] = 20;
	mp['r'] = 30;
	mp['a'] = 40;
	
	//it -> first 是当前映射的键
	//it -> second是当前映射的值 
	for(map<char,int>::iterator it = mp.begin(); it != mp.end(); it++)
	{
		cout << it -> first << " " << it -> second << endl;
	}
	
	return 0;

}


```

输出结果：

```php
a 40
m 20
r 30

```


接下来似乎发现了一个很有意思的现象：map会以键从小到大的顺序自动排序，即按 a<m<r的顺序排列这三对映射。这是由于map 内部是使用红黑树实现的（set也是），在建立映射的过程中会自动实现从小到大的排序功能。

### map.find()

map.find(key)返回的是iterator，iterator->first 是键值 ，iterator->second 是值

判断是否找到可以用

```c++
map<int,int> m;
m[1]=1;
map<int,int>iterator it=m.find(1);
if(it==m.end()){
    //没有找到
    cout<<"no find"
}else if(it!=m.end()){
    cout<<"键值是："<<it.first<<endl<<"值是："<<it.second;
}
```

### map.earse()

