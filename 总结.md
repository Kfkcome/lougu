# 刷算法题总结

## 【深基5.例7】工艺品制作 | P5729

第一次错误：范围1< w,x,h <= 20数组大小设置错误设置为了20所以会有RE(RuntimeError)

## [AHOI2001] 彩票摇奖 | P2550

第一次暴力实现4ms暴力实现
其实可以使用号码作为分数下标这样可以快速查找到是否是中奖号码。

第二次用号码作为下标 仍然是4ms改进不大，但是第二次写
把

```C++
int **a=new int *[n];
cin>>n;
```

顺序写反了导致一直RE很难找到错误

## P5730 【深基5.例10】显示屏

看题不仔细，输入输出的格式要仔细看
输出的是大写的X并且其中没有空格，要仔细看
本题没有什么难度和算法

## 梦中的统计 | P1554

一次过

### 学到新知识：stoi、to_string

![Alt text](image.png)
注意：

1. std::to_string()有9种重载形式，分别对应int/long /long long/unsigned/unsigned long/unsigned long long/float/double/long double。
2. b默认值为10，即10进制；若b = 0，则表示自动确定string序列的基数，如0x7f会自动以16进制为基数。
3. 对于转换为浮点型的字符串(上述表格的最后3个)，可以识别小数点和指数e、E，如std::stod(".3e3")结果为300。
**to_string**例子：

```c++
std::string pi = "pi is " + std::to_string(3.1415926);
std::string perfect = std::to_string(1 + 2 + 4 + 7 + 14) + " is a perfect number";
std::cout << pi << '\n';
std::cout << perfect << '\n';
```

结果：
![At text](image-1.png)
**stoi**例子

```c++
std::string str_dec = "2001, A Space Odyssey";
std::string str_hex = "40c3";
std::string str_bin = "-10010110001";
std::string str_auto = "0x7f";

std::string::size_type sz;   // alias of size_t

//1.转换基数为10进制，sz保存','下标，i_dec = 2001
int i_dec = std::stoi(str_dec, &sz);
//2.转换基数为16进制。所以i_hex = 0x40c3,十进制为16579
int i_hex = std::stoi(str_hex, nullptr, 16);
//3.转换基数为2进制。所以i_bin = -10010110001B,十进制为-1201
int i_bin = std::stoi(str_bin, nullptr, 2);
//4.自动确定 转换基数
int i_auto = std::stoi(str_auto, nullptr, 0);

std::cout << str_dec << ": " << i_dec << " and [" << str_dec.substr(sz) << "]\n";
std::cout << str_hex << ": " << i_hex << '\n';
std::cout << str_bin << ": " << i_bin << '\n';
std::cout << str_auto << ": " << i_auto << '\n';
```

结果：
![Alt text](image-2.png)

## [NOIP2014 普及组] 珠心算测验 | P2141

第一遍过：使用了debug调试发现有一步没有包含在if大括号中间，发现修改后通过
时间复杂度O（3）

可以发现求一个数能否被其他数求和时，每求一个数就要算以下所有其他数能求和出来的数，导致了很多重复的运算

stl set集合使用方法()
集合和

其他方法
优化时间复杂度
使用stl中的集合

## 爱与愁的心痛 | [P1614](https://www.luogu.com.cn/problem/P1614)

第一遍过 ：使用暴力复杂度为O(n*2) 其中有不少重复的运算

求区间的和用前缀和数组来减少时间复杂度

第二遍：使用前缀和数组 ，不过前缀和数组的大小设置的要比原数组的大小大1

例子： 

```c++
    int *a=new int [n+1];
    a[0]=0;//初始化使用前缀和第一个元素为0
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[i]=a[i-1]+a[i];//前缀和实现
    }
```



## 【Mc生存】插火把 | [P1789](https://www.luogu.com.cn/problem/P1789)

第一遍交失败 **数组大小设置没有根据题目的数据范围来设置**

**数组循环的for的条件设置的有问题** 注意for的终止条件

变量命名不要重复尤其是 	i,j,k等



## [USACO1.2] 方块转换 Transformations | [P1205](https://www.luogu.com.cn/problem/P1205)

第一遍交失败：判断if时候条件写错，多种情况混合在了一起，这个不满足时那个可能满足，有一个不满足应该都否定了，但是这样写后，导致互补一会这种情况满足，一会另一种情况满足 **最后好像满足了，实际上都不满足，注意一票否决的情况**

第二遍失败 ：模拟出错注意耐心审题，不能一概而论想像**要实际在脑子中或者手写模拟一下**


## set（集合）

### 1. 介绍

set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。

即：set里面的元素不重复 且有序

```c++
//头文件
#include<set>
//初始化定义
set<int>se;
```

1. 函数方法

  | 代码                  | 含义                                                                |
  | --------------------- | ------------------------------------------------------------------- |
  | s.begin()             | 返回set容器的第一个元素的地址（迭代器）                             |
  | s.end()               | 返回set容器的最后一个元素的下一个地址（迭代器）                     |
  | s.rbegin()            | 返回逆序迭代器，指向容器元素最后一个位置                            |
  | s.rend()              | 返回逆序迭代器，指向容器第一个元素前面的位置                        |
  | s.clear()             | 删除set容器中的所有的元素,返回unsigned int类型O(N)                  |
  | s.empty()             | 判断set容器是否为空                                                 |
  | s.insert()            | 插入一个元素                                                        |
  | erase(iterator)       | 删除定位器iterator指向的值                                          |
  | erase（first,second） | 删除定位器first和second之间的值                                     |
  | erase(key_value)      | 删除键值key_value的值                                               |
  | s.find(元素)          | 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 |
  | s.lower_bound(k)      | 返回大于等于k的第一个元素的迭代器                                   |
  | s.upper_bound(k)      | 返回大于k的第一个元素的迭代器                                       |

**查找**

   | 代码             | 含义                                                                |
   | ---------------- | ------------------------------------------------------------------- |
   | s.find(元素)     | 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 |
   | s.lower_bound(k) | 返回大于等于k的第一个元素的迭代器                                   |
   | s.upper_bound(k) | 返回大于k的第一个元素的迭代器                                       |

1. 访问
    a.迭代器访问

```c++
for(set<int>::iterator it=s.begin();it!=s.end();it++)
 cout<<*it<<" ";

b.简便的方法

for(auto i : s)
 cout<<i<<endl;

c.访问最后一个元素

//第一种
cout<<*s.rbegin()<<endl;

 //第二种
set<int>::iterator iter = s.end();
iter--;
cout<<(*iter)<<endl; //打印2;

//第三种
cout<<*(--s.end())<<endl;

1. 重载<运算符
//重载<运算符
struct cmp {
    bool operator () (const int& u, const int& v) const
    {
       // return + 返回条件
    }
};
set<int, cmp> se;
```

其它的set
multiset:元素可以重复，且元素有序
unordered_set ：元素无序且只能出现一次
unordered_multiset ： 元素无序可以出现多次